■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<1> 데이터베이스?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류하여 정리해 놓은 [자료의 집합]을 말한다.
데이터베이스 조건( 입.기 )  // 입: 입사시험문제. // 기 : 정보처리 기사 시험문제.
	실시간 접근성, 지속적인 변화(=최신의 정보가 정확하게 저장), 동시 공유 등

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<2> RDBMS (Relational Database Management System, 관계형 데이터베이스 관리 시스템) 란?	(입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●데이터가 [컬럼(column=열)]과 [로우(Row=행)]로 이루어진 [테이블]에 저장되며, [테이블]들 사이에 관계를 설정하여
 관리하는 SW 또는 시스템을 말한다.

●RDBMS 제품의 종류
	Oracle 사의 Oracle		=> 대기업용. 현재 대기업 공기업 프로젝트에 제일 많이 사용하고 있음.
	MS 사의 MS-SQL		=> 대기업용
	Sun Microsystems 사의 MYSQL => 중소기업용
	Sybase
	DB2 등
●고객의 정보를 저장하는 테이블 custumer가 있다면 아래와 같은 구조로 데이터를 저장하여 관리한다.
면 아래와 같은 구조로 데이터를 관리한다.
---------------------------------------------------------------------

		custumer                             => 테이블명
------------------------------------------
고객번호       고객명      주소       전화번호         =>column 명
------------------------------------------
1              저팔계      서울      02-1234-1234       =>row(행)
------------------------------------------
2              사오정      부산      02-2345-2345       =>row(행)
------------------------------------------
3              손오공      제주      02-3456-3456       =>row(행)
------------------------------------------
↓              ↓          ↓            ↓
column      column      column      column
(컬럼)       (컬럼)       (컬럼)        (컬럼)
(열)          (열)         (열)          (열)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<3> SQL(Structured Query Language) 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS에 접근해서 데이터의 [입력], [수정], [삭제], [검색] 하는 등의 기능을 가진 RDBMS 관리 언어 이다.
  <참고> DB, 즉 오라클을 배운다라는 말은 SQL 언어를 배우는 것과 동일하다.
●특징
	▶[절차적 언어]가 아닌 [구조적 언어]이다.  //솔루션 회사에서 물어볼 수 있음.
	   <참고>절차적(procedural) 언어 (입)
		▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. (C, Java 등)
	   <참고>구조적(structured) 언어 (입)
		▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만
                      	   나열하만 로직이 처리되는 언어. (SQL...)

	// Oracle ex) 구조적 언어
	select count(*) from employee


●SQL 종류 ( 기, 입)
	--------------------------------
	DDL(Data Definition Language = 데이터 정의 언어)
	--------------------------------
		▶객체를 생성, 수정, 삭제 등의 작업을 한다.
		----------------------
		CREATE => 객체 생성
		ALTER => 객체 수정. <조심>update가 아니다. 시험문제에 자주 등장.
		DROP => 객체 삭제
		기타 등등
		----------------------
		<주의>오라클에서 객체란 이름을 가지고 저장되는 놈들을 객체라 부른다. 자바의 객체와 다르다.
		<참고>오라클에서 객체는 [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등 을 말한다.

	--------------------------------
	DML(Data Manipulation Language = 데이터 처리 언어)
	--------------------------------
		▶테이블 안의 데이터를 입력, 수정, 삭제, 검색 등의 작업을 한다.
		--------------------------------
		INSERT => [행단위]의 데이터 입력
		UPDATE => [셀 단위]의 데이터 수정/삭제
		DELETE => 행 단위의 데이터 삭제
		SELECT => n행 m열의 데이터 검색 SQL 공부의 90%차지한다. DB 실력은 SELECT 구사 능력이다.
		기타 등등
		--------------------------------
		<문> 셀에 들어있는 데이터를 제거하는 SQL구문은?  => UPDATE !!!	학원 프로젝트에 주도적으로 참여 했는지 알 수 있는 질문.
		<문> 행을 제거하는 SQL구문은?  => DELETE !!!

	--------------------------------
	DCL(Data Control Language = 데이터 제어 언어)
	--------------------------------
		COMMIT		=> 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정
		ROLLBACK	=> 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소
		GRANT		=> 접근제어, 작업권한허용
		REVOKE		=> 권한제거



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<4>트랜잭션(Transaction) 이란 뭡니까? (입.기.실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위를 말한다.	//포괄적
●트랜잭션은 주로 입력 또는 수정 또는 삭제 SQL 구문 실행 시 설정한다.		//실무적
●트랜잭션이 걸린 작업은 가상 작업이 되고 rollback 를 실행하면 모두 취소되고 commit 를 실행하면
  가상작업이 모두 실제로 작업으로 인정된다.
●<주의>트랜잭션은 의도를 가지고 설정하는 것이다.
●<주의>트랜잭션이 없는 작업은 N가지 이상의 다양한 결과로 진행 될 수 있다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<5>오라클에서 [계정] 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●오라클에 접속하는 사용자를 말한다.
●사용자 마다 권한을 다르게 줄 수 있다.
●오라클은 다수의 클라이언트에게 동시에 정보를 제공하는 서버이므로 서버의 특징인 계정과 암호를 가지고 있다.
--------------------------------
<참고>서버(SERVER)?
--------------------------------
	다수의 클라이언트에게 동시에 정보를 제공하는 H/W 나 S/W 를 말한다.

●오라클 계정의 종류
	-------------------------------------------------------------------
	SYS		-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다. 반지의 제왕!
	-------------------------------------------------------------------
	SYSTEM		-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다.
			단 [데이터베이스] 생성 권한이 없다.
	-------------------------------------------------------------------
	SCOTT		-> 오라클 설치 시 기본적으로 만들어지는 계정. 권한이 거의 없다.
	-------------------------------------------------------------------
	생성 계정		-> 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정된다.
			주로 SYS, SYSTEM 계정 또는 SYS, SYSTEM 계정과 동일한 권한을 가진 계정이 만든다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<6>데이터베이스 차원에서 스키마 (Schema) 란 뭡니까? (입, 기, 실) 대형 솔루션 회사 입사 시험 타겟!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[데이터베이스의 구조]에 대한 정의와 제약조건 등을 기술한 [명세서]를 말한다.	// 데이터 베이스 한정 정의.
●[계정]이 생성한 모든 [객체]들을 의미 한다. (오라클 객체=>테이블, 뷰, 인덱스, 프로시저, 트리거 등)
  객체들이 DB 구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.
●[kim] 계정이 객체(테이블,인덱스,뷰 등)들을 생성했다면 이 객체들 모두를 가리켜 [kim 스키마]라고 한다.
●생성되는 객체는 [계정명.객체명] 형식으로 저장된다.

<예>abc 계정으로 로그인해 => employee 테이블 생성.  abc.employee 형태로 저장됨.
<예>kim 계정으로 로그인해 => employee 테이블 생성.  kim.employee 형태로 저장됨.
<예>kim 계정으로 로그인해 => employee 테이블 생성.  kim.employee 형태로 저장 안됨. 이미 있으니까.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<7>데이터베이스 차원에서 테이블(table) 란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS 에서 데이터가 실질적으로 저장되는 [논리적 장소(=S/W 적인 장소)]를 말한다.
●[컬럼(column=열)]과 [로우(Row=행=record)]로 구성되어 있다.
●테이블은 이름가지고 저장되는 객체의 한 종류이다.
●개발자 입장에서 제일 손이 많이 가는 객체이다.
●테이블에 데이터를 입력하는 SQL 이 insert 이다.
●테이블에 데이터를 수정하는 SQL 이 update 이다.
●테이블에 데이터를 삭제하는 SQL 이 delete 이다.
●테이블에 데이터를 검색하는 SQL 이 select 이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<8>테이블(table) 을 생성하는 SQL 구문의 형식은?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

-------------------------------------
CREATE TABLE 테이블명(
		컬럼명1		자료형		제약조건
		, 컬럼명2		자료형		제약조건
		, ~
		, 컬럼명n		자료형		제약조건
);
-------------------------------------
CREATE TABLE 테이블명(
		컬럼명1		자료형		제약조건,
		컬럼명2		자료형		제약조건,
		 ~         ~           ~	,
		컬럼명n		자료형		제약조건
);
-------------------------------------
	-------------------------------------
	자료형(Data type) => 테이블의 컬럼에 입력될 데이터의 유형을 말한다. 문자형, 숫자형, 날짜형 등이 있다.
	-------------------------------------
	제약조건 => 입력되는 데이터의 입력 가능 조건을 말한다. 제약조건에 위배되는 데이터는 삽입될 수 없다
			제약조건이 생략되면 데이터가 입력되지 않을 경우 null 이 저장된다.
	-------------------------------------
	<주의>테이블명, 컬럼명 제작 규칙
			▷영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다.
			▷30자를 초과할 수 없다. SQL 예약어는 사용할 수 없다.
			▷하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야한다.
			▷테이블명, 컬럼명, 제약조건명을 " 로 감싸거나 " 없이 그냥 써도된다.
			▷▷테이블명, 컬럼명 은 가독성 있게 주는 것이 제일 중요하다.

	자바에서 " 와 ' 가 언제 사용되는지 설명?
	String 형 ""
	char 형 ''

	String str1 = "산";
	String str2 = '산';	// '' 때문에 에러/ 변수선언이 먼저이기 때문에 String 이기때문에 ""로 바꿔주어야 맞다.
	char str3 = '산너머';  // char 형이라서 길이가 세글자라서 에러.
	String str4 = '산너머'; // "" 로 안써서 에러
	// 셋다 들어간 데이터가 잘못된것이다.

	오라클에서 " 와 ' 가 언제 사용되는지 설명?

	자바스크립트에서 " 와 ' 가 언제 사용되는지 설명?


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<9> 오라클에서 자료형의 종류는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
오라클은 대문자가 원칙이지만 소문자도 상관은 없음.

-------------------
CHAR(s)
-------------------
	▶고정길이 문자열 저장. s는 byte수를 의미.
	▶설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
	▶설정 크기보다 입력 문자 크기가 크면 ? 행 자체가 입력되지 않는다.
	▶<예>CHAR(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
			<참고>영문 1자는 1byte 차지, 한글 1자는 2byte차지.
	▶최대크기는 2000Byte 이다.
	▶CHAR 는 CHAR(1) 과 동일. ex) 성별 표현. m/w 두가지만. 표현하기 때문.

-------------------
VARCHAR2(s)
-------------------
	▶가변길이 문자열 저장. s 는 byte 수를 의미.
	▶설정 크기보다 입력문자 크기가 작으면 크기가 자동으로 줄어든다. (DB 서버 부담은 증가)
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<예>VARCHAR2(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
	▶보통 테이블을 설계할 때는 CHAR 타입보다는 VARCHAR2 타입을 많이 사용한다.
		임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문이다.
	▶최대크기는 4000Byte 이다.
	▶VARCHAR2 만 쓸수는 없다. // CHAR랑 혼동하지 말것!!

-------------------
NUMBER(p,s)
-------------------
	▶정수형 또는 실수형 숫자 저장.
	▶p(precision) => 전체 자릿수(1~38). s(scale) => 소수점이하 자릿수(-84~127)
	▶s 생략 시 디폴트 0 설정.
	▶NUMBER 는 즉 p(precision), s(scale) 모두 생략 시 정수, 소수점이하 자릿수 합쳐 40자리 까지 저장.
	▶소수점 자리수가 넘치면 반올림하고 정수 자리수가 넘치면 오류가 난다. 즉, 행 입력이 안된다.
	--------------------------------------------------
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.56 저장하면? 1234.56 저장.
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.567 저장하면? 1234.57 저장. 반올림 한 후 소수점 2자리 까지 저장.
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 12345.6 저장하면? 저장오류(행 자체가 못들어감). 정수 자릿수 부족으로 오류
	--------------------------------------------------
	▶<예> NUMBER(3) 라고 지정한 컬럼에 123 지정하면? 123 저장
	▶<예> NUMBER(3) 라고 지정한 컬럼에 123.4 지정하면? 123 저장. 소수점 1자리에서 반올림해서 저장.
	▶<예> NUMBER(3) 라고 지정한 컬럼에 1234 지정하면? 저장오류. 정수부문 자릿수 부족으로 오류.


-------------------
DATE
-------------------
	▶[년, 월, 일, 시, 분, 초] 저장.
	▶저장 범위는 BC 4712년 1월 1일~9999년 12월 31일.
	▶<참고>보통 날짜형 데이터는 SQL 문장에서 [TO_CHAR] 변환함수, [TO_DATE] 변환함수와 같이 사용된다.

	▶<참고>2021년06월11일 부터 ▶2021년12월25일 까지 남은 일수 검색하는 SQL 구문 작성?
		---------------------------------------------------
		select to_date('2021225', 'YYYYMMDD')-to_date('20210611', 'YYYYMMDD') from dual
		---------------------------------------------------
	▶<참고>오늘 날짜를 예쁘게 연-월-일 로 검색하는 SQL 구문작성?
		---------------------------------------------------
		select to_char(sysdate. 'YYYY-MM-DD') from dual
		---------------------------------------------------
	▶<참고>변환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER] 와 같이 사용된다.

------------------
<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE 도 있다.
<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.
------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<10> 오라클에서 제약조건의 종류는? (입, 기, 실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

----------------
not null
----------------
	▶반드시 데이터가 입력돼야 한다. 비지마! 필수입력 데이터 니까!

----------------
unique
----------------
	▶중복되는 데이터는 입력 불가능하다. 중복마!
	▶<예>주민번호, 전화번호, 직원번호 등등
	▶일반적으로 또는 관용적으로, 실무적으로 unique 을 가진 컬럼은 not null 도 같이 들어간다.

----------------
default
----------------
	▶데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
	▶<예>회원가입할 때 가입날짜를 입력하지 않아도 그 당일날짜가 저장되는 경우.

----------------
check
----------------
	▶지정한 데이터만 입력 가능하다.
	▶<예>성별 입력 시 남 또는 여 만 입력되는 경우

----------------
Primary key(PK)
----------------
	▶not null, unique 의 제약조건 성질을 가진다. 즉 행과 행을 구분할 수 있는 유일한 데이터가 입력된다.
	▶차후에 foreign key에 의해 참조 당할수도 있다.
	▶하나의 테이블에 하나의 Primary key만 설정 할 수 있다. 즉 테이블당 0~1개만 줄 수 있다.
	▶[기본키], [주키] 라고도 한다.

----------------
foreign key(FK)
----------------
	▶Primary 키에 존재하는 데이터만 삽입될 수 있다. (=Primary 키를 참조하는 키다.)
	▶<주의>예외적으로 null 값은 입력 가능하다. 즉, 데이터가 입력되지 않을수도 있다.
	▶하나의 테이블에 0개 이상의 foreign key를 설정할 수 있다.
	▶table과 table간의 관계를 설정하는 키다.
	▶[참조키], [외래키], [관계키], [종속키] 라고도 한다.


(예시)

									employee
	=================================================
	e_name    dep_name    salary    jikup   jumin_num
	=================================================
	사오정     관리부     5000      대리    901225-1234543
	저팔계     영업부     6000      과장    ~
	손오공     자재부     7000      부장    ~
	사오정     관리부     5000      대리    901225-1234543



	PK							employee
	=================================================
	e_no    e_name    dep_name    salary    jikup
	=================================================
	1       사오정     관리부     5000      대리
	2       저팔계     영업부     6000      과장
	3       손오공     자재부     7000      부장
	4				사오정			관리부			5000			대리


(예시)

	dept
=====================================================
dep_no(PK)     dep_name
=====================================================
10             관리부
20             자재부
30             홍보부
40             사업부


                  employee
===============================================================
e_no(PK)     e_name    dep_no(FK)    salary  jikup     mgr_e_no(FK)
===============================================================
1         사오정       10            5000     대리       3
2         저팔계       20            6000     과장       3
3         손오공       30            7000     부장       null
4         사오정       40            5000     대리       2


            customer
=====================================================
c_no(PK)     c_name    phone  e_no(FK)
=====================================================
1         사오순        ~     2
2         저팔순        ~     4
3         손오순        ~     1
4         사오순        ~     2


OX문제 20210611.md 참고.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<11> 시퀀스(sequence) 가 뭡니까?	(입50%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[고유 일련 번호]를 생성해서 제공하는 객체이다. 일종의 [일련 번호 생성기] 이다.
●주로 하나의 테이블에서 PRIMARY KEY 로 지정된 컬럼명에 입력될 [일련 번호] 값을 생성한다.
●<비유>은행에서 번호표 뽑는 기계와 동일한 기능을 가진다.
--------------------------
●시퀀스 생성 SQL 구문
--------------------------
	-----------------------------------
	create sequence 시퀀스명
		start with 시작값
		increment by 증가값
		minvalue 최소값
		maxvalue 최대값;
	-----------------------------------
	예
	-----------------------------------
	create sequence sq_emp
		start with 1
		increment by 1
		minvalue 1
		maxvalue 9999;
	-----------------------------------
	create sequence sq_emp
		start with 999
		increment by -1
		minvalue 1
		maxvalue 9999;
	-----------------------------------
--------------------------
●증가된 새 일련번호 얻는 SQL 구문
--------------------------
	시퀀스명.nextval
--------------------------
●마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
--------------------------
	시퀀스명.curval
--------------------------
●시퀀스 삭제 SQL 구문
--------------------------
	drop sequence 시퀀스명;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<12> 오라클을 연습하려면 어떤 SW를 설치해야 합니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다.
<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다,
	▶IP            => ip주소 또는 localhost
	▶사용자        => system
	▶암호          => 설정암호
	▶SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<13> system 계정으로 접속하니 쓸 때 없는 테이블이 많아 번거롭네요.
     system 계정과 동일한 권한을 가지는 새로운 계정을 만들려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
	create user king  identified by k123;
② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
	grant connect,resource,dba to king;
③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다,
	●IP            => 127.0.0.1 또는 localhost
	●사용자        => king
	●암호          => k123
	●SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<14>아래 고객 요구사항에 맞는 테이블을 만들면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	부서를 관리하고 싶어요.
		관리하고 싶은 정보는 부서명, 부서 위치 입니다.
	-----------------------------------------------------------------
	직원정보를 관리하고 싶어요
		관리하고 싶은 정보는 직원명, 직급, 입사일, 소속부서명, 연봉, 주민번호, 전화번호, 연봉등급, 직속상관명 입니다.
	-----------------------------------------------------------------
	고객정보를 관리하고 싶어요
		관리하고 싶은 정보는 고객명, 전화번호, 주민번호, 담당직원명 입니다.
	-----------------------------------------------------------------
	연봉등급을 관리하고 싶어요
		관리하고 싶은 정보는 연봉등급, 등급별최소연봉, 등급별최대연봉
	-----------------------------------------------------------------

	SQL_02_teacher0615.sql 에 정답 있음.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<15> employee 테이블에서 모든 컬럼, 모든행의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	select * from employee;
	-----------------------------------------------------------------
	select emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num mgr_emp_no from employee;
	-----------------------------------------------------------------
	select
		emp_no
		, emp_name
		, dep_no
		, jikup, salary
		, hire_date, jumin_num
		, phone_num
		, mgr_emp_no

	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<16> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 컬럼의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no, emp_name, jikup, salary, hire_date
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<17> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 을 검색하면서
	별칭(=alias)을 즉, 헤더를 사원번호, 직원명, 직급, 연봉, 입사일로 하고
	연봉에 '만원' 이란 문자를 붙여 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-----------------------------------------------------------------
	select
		emp_no             as "직원번호"
		, emp_name         as "직원명"
		, jikup            as "직급"
		, salary||'만원'   as "연봉"
		, hire_date        as "입사일"
	from
		employee;
	-----------------------------------------------------------------
		<참고> as 생략이 가능하다.
		<참고> 별칭에 공백이 없으면 "" 도 생략이 가능하다. 그치만 무조건 사용하는것이 좋다. 일단 한놈만 패자...
		<참고> 오라클에서 연결 연산자는 + 가 아니라 || 이다. 자바와 다르다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액을 검색하면? (세금은 연봉의 12%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	select
		emp_name               as "직원명"
		, jikup                as "직급"
		, salary*0.12||'만원'   as "세금"
		, salary*0.88||'만원'   as "실수령액"
	from
		employee;
	-----------------------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<19> employee 테이블에서 직급을 중복없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select distinct jikup from employee;
	-----------------------------------------------
	select unique jikup from employee;
	-----------------------------------------------
	select distinct(jikup) from employee;
	-----------------------------------------------
	select unique(jikup) from employee;
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<20> employee 테이블에서 부서번호와 직급을 중복 없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select distinct dep_no, jikup from employee;
	select unique dep_no, jikup from employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<21> employee 테이블에서 연봉이 3000 이상인 직원을 검색해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary>=3000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<22> employee 테이블에서 연봉 오름차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by salary asc;
	-----------------------------------------------
	select * from employee order by salary ;
	-----------------------------------------------
	select * from employee order by 5 asc; -- 컬럼명 위치번호.
	-----------------------------------------------
	select * from employee order by 5 ;     -- asc 생략 가능.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<23> employee 테이블에서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  -----------------------------------------------
	select * from employee order by salary desc;  -- 내림차순
  -----------------------------------------------
	select * from employee order by 5 desc;
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<24> employee 테이블에서 부서번호 오름차순을 유지하면서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by dep_no asc, salary desc;
	-----------------------------------------------
	select * from employee order by dep_no , salary desc;  -- asc 생략 가능하지만 혼동될 가능성이 높다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<25> employee 테이블에서 직급이 높은 순서 나열해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by jikup desc;
	-----------------------------------------------
	select * from employee order by jikup asc;
	-----------------------------------------------
	위 답은 모두 잘못된것임.
	직급순서는 인간이 생각하는 기준이지 오라클의 단순한 정렬개념하고는 다르다.
	추후 조건문을 써서 정렬의 기준을 바꾸어야 답이 나온다. 나중에 합시다.
	그래도 알고 싶다면 아래가 답이다.
	-----------------------------------------------
	select * from employee order by decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4), salary desc; -- 직급순서와 연봉순서. 복합.
	-----------------------------------------------
	<명심> 고객의 요구 사항을 보고 select 문을 작성하는것도 중요하지만
	이미 작성된 select 문을 보고 고객의 요구 사항을 알아내는 것도 중요하다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<26> employee 테이블에서 부장만 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup=='부장';   -- 오라클은 '==' 은 없다.
	select * from employee where jikup='부장';    -- 이것이 정답.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<27> employee 테이블에서 20번 부서의 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<28> employee 테이블에서 20번 부서 또는 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 or jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<29> employee 테이블에서 과장 중에 연봉 3400 이상을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary>=3400 and jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<30> employee 테이블에서 실수령 액이 4000만원이상 받는 직원을 검색하면? 단, 세금이 12% 라고 가정하자.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary*0.88>=4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서 부서번호가 내림차순이면서
	사장이 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by salary*0.12 desc, dep_no desc where jikup!='사장';
	select * from employee where jikup != '사장' order by salary*0.12 desc , dep_no desc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<32> employee 테이블에서 20번 부서 중에 연봉 2000~3000 사이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and salary>=2000 and salary<=3000;
	select * from employee where dep_no=20 and salary between 2000 and 3000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<33> employee 테이블에서 직속 상관이 없는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<34> employee 테이블에서 직속 상관이 있는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is not null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<35> 오라클 4대 천왕?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	내장함수               => 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴한다.
	join (조인)            => 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
	subquery (서브쿼리)    => SQL 구문안의 select 문
	group by              => 통계관련 작업

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<36> employee 테이블에서 [최소 연봉]. [최대 연봉], [평균 연봉], [연봉총합], [총인원수]을 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select

  	min( salary )    as "최소연봉"  -- salary 컬럼에서 최소값을 리턴
  	,max( salary )   as "최대연봉"  -- salary 컬럼에서 최대값을 리턴
  	,avg( salary )   as "평균연봉"  -- salary 컬럼에서 평균값을 리턴.
                                 -- <조심>avg 사용 시 null 있으면 더할때 빠지고 나누는 개수에서도 빠진다.
  	,sum( salary )   as "연봉총합"  -- salary 컬럼에서 총합을 리턴.
  	,count( salary ) as "총인원수"  -- count(*) 는 총행의 개수
	from
  	employee;
	-----------------------------------------------------
	min, max, avg, sun, count 함수들을 [그룹함수] 또는 [통계함수] 라고 부르기도 한다.
	그룹지어서 연산을 하는 함수이기 때문이다.
	그룹함수들은 주로 group by 와 같이 많이 사용한다.
	-----------------------------------------------------
	min, max, avg, sun, count 함수들은 null 값은 제외하고 계산한다.
	-----------------------------------------------------
	count(컬럼명) => 컬럼안의 null 아닌 데이터의 개수를 리턴한다.
	count(*)     => 행의 개수를 리턴한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<37> 아래 SQL 구문은 무슨 문제의 답인가?
     select count(emp_no) from customer;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	담당 직원이 있는 고객의 명수는?
	emp_no 컬럼안의 담당 직원의 직원번호이므로 직원번호의 개수는 결국  담당직원이 있는 고객의 명수가 된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<38> 고객을 담당하고 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct emp_no) from customer;
	-----------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39> 직속상관이 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(mgr_emp_no) from employee;
	-----------------------------------------------------
	<주의>mgr_emp_no 컬럼안의 데이터가 뭔지 먼저 파악해야한다. 바로 직속 상관의 직원번호 이다.
	-----------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39-1> 부하직원이 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct mgr_emp_no) from employee;
	-----------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거
	-----------------------------------------------------
	<주의>count에는 업무적 특징(고객요구사항)이 숨어 있어 조심히 날려야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<40> employee 테이블에서 [직원번호], [직원명], [생일월-생일일] 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no                                               "직원번호"
		,emp_name                                            "직원명"
		,substr(jumin_num,3,2)||'-'||substr(jumin_num,5,2)   "생일월일"  -- 세번째에서 두개 출력
	from
		employee;
	-----------------------------------------------------
	*****substr(컬럼명, 복사할시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기. 엄청난 사용빈도를 자랑한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력하면?
	단, 주민번호는 901225-2****** 형태로 출력하세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		cus_no
		,cus_name
		,tel_num
		,substr(jumin_num,1,6)||'-'||substr(jumin_num,7,1)||'******'
		,emp_no
	from
		customer;
	-----------------------------------------------------
	<주의>모든 행이란 말이 나오면 where 절이 없다.
	-----------------------------------------------------
	*****substr(컬럼명, 복사할시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기. 엄청난 사용빈도를 자랑한다.
	-----------------------------------------------------
	|| => 좌우의 문자열을 붙이는 연산자, 즉 연결 연산자이다.
	<조심> 오라클에서 + 는 연결연산자가 아니라 사칙연산자 이다.
	'tom'||'my'
	'tom'||123   -> 	'tom'||'123'   -> 	'tom123'


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<42> customer 테이블에서 고객번호, 고객명, 담당직원번호 를 출력하면?
	단, 담당직원번호가 없으면 null 출력하지 말고 '없음' 으로 표시 하삼!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		cus_no
		,cus_name
		,nvl(emp_no||'','없음')
	from
		customer;
	-------------------------------------------
	nvl( 컬럼명, null값일때 대체데이터)
	-------------------------------------------
	=>컬럼명 안의 데이터가 null 이 아니면 그냥 리턴하고
	null 이면 null값일체 대체데이터 를 리턴하는 [null 처리 내장함수]이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부 를 출력하면?
	단, 직원번호가 있으면 '있음', 없으면 '없음'으로 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
  	cus_no
  	,cus_name
  	,nvl2(emp_no,'있음', '없음')
	from
  	customer;
	-------------------------------------------
	nvl2( 컬럼명, null값아닐때대체데이터, null값일때대체데이터 )
	-------------------------------------------
	=>컬럼명 안의 데이터가 null 이 아니면 null값아닐때 대체데이터 출력하고
 	null 이면 null값일체 대체데이터 를 리턴하는 [null 처리 내장함수]이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<44> employee 테이블에서 직원번호, 직원명, 직급, 성별 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
  	emp_no
  	,emp_name
  	,jikup
  	,case
    	substr(jumin_num,7,1)
    	when '1' then '남'
    	when '3' then '남'
    	when '2' then '여'
    	when '4' then '여'
  	end
	from
  	employee;
	--------------------------------------------------
	select
  	emp_no
  	,emp_name
  	,jikup
  	,case
    	substr(jumin_num,7,1)
    	when '1' then '남'
    	when '3' then '남'
    	else '여'
  	end
	from
  	employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '남'
			when substr(jumin_num,7,1)='3' then '남'
			else '여'
		end
	from
		employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','남'
		,'3','남'
		,'여'
		)
	from
		employee;
	***************************************************
	case ~ end 구문의 패턴 설명
	***************************************************
	<패턴1>--------------------------------------------------
	case 컬럼명
		when 데이터1 then 리턴값1
		when 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	--------------------------------------------------
		컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
		컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
		~
		그외에는 리턴값n 을 리턴하기
	<패턴2>--------------------------------------------------
	case
		when 컬럼명 = 데이터1 then 리턴값1
		when 컬럼명 = 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	--------------------------------------------------
		컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
		컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
		~
		그외에는 리턴값n 을 리턴하기
	--------------------------------------------------
	패턴2 에서 `=` 대신에 필요에 따라 `>=, >, <, <=, !=` 등의 비교연산자도 사용할 수 있다.
	필요에 따라 `else 리턴값n` 는 생략 될 수 있다.
	***************************************************
	decode(~) 구문의 패턴 설명
	***************************************************
		decode(
			컬럼명
			, 비교데이터1, 리턴값1
			, 비교데이터2, 리턴값2,
		  , ~
			, 리턴값n
		)
	--------------------------------------------------
	컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
	컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
	~
	그외에는 리턴값n 을 리턴하기
	--------------------------------------------------
	필요에 따라 리턴값n 는 생략될수 있다.
	--------------------------------------------------
	decode 단점
		=> 같다라는 경우에만 사용된다.
		=> 오라클에서만 사용되는 오라클 전용함수이다. case ~ end 구문은 모든 DB에서 사용가능하다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<45> employee 테이블에서 직원번호, 직원명, 직급, 출생년도(4자리) 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end ||substr(jumin_num,1,2) "출생년도"
	from
		employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','19'
		,'2','19'
		,'20'
		) ||substr(jumin_num,1,2) "출생년도"
	from
		employee;
	---------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<46> employee 테이블에서 직원번호, 직원명, 직급, 출생년대(4자리) 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end ||substr(jumin_num,1,1)||'0년대' "출생년대"
	from
		employee;

	----------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','19'
		,'2','19'
		,'20'
		) ||substr(jumin_num,1,1)||'0년대' "출생년도"
	from
		employee;
	----------------------------------------------
	<참고>
	년도 => 1년 단위
	년대 => 10년 단위

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<47> employee 테이블에서 나이순으로 출력하면? 연장자가 먼저 나오도록.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
	 *
	from
		employee
	order by
		case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end || substr(jumin_num,1,6)

		asc; --asc는 생략 가능하다.
	----------------------------------------------
	아래 처럼하면 안된다. 2000년 생이 먼저 나온다. 2000년 생은 주민번호가 00 으로 시작한다.
	----------------------------------------------
	select * from employee order by jumin_num asc;
	----------------------------------------------
	order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case 가 끌어 안아서 다른 형태로 바꾼 것이다.
	----------------------------------------------
	order by 구문의 패턴
	----------------------------------------------
		----------------------------------------------
		order by 컬럼명|컬럼순서번호|컬럼알리아스 [asc]|desc;
		----------------------------------------------
		컬럼알리아스 = 컬럼을 별칭 헤더.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<48> employee 테이블에서 직급순서대로 정렬하여 모든 컬럼을 보이면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	order by
		case jikup
			when '사장' then 1
			when '부장' then 2
			when '과장' then 3
			when '대리' then 4
			when '주임' then 5 else 6
		end
		asc;
	----------------------------------------------
	--decode로 변경--
	select * from employee
		order by
			decode( jikup
				,'사장', 1
				,'부장', 2
				,'과장', 3
				,'대리', 4
				,'주임', 5
				,6
			)
			asc;
	----------------------------------------------
			select * from employee
				order by
					decode( jikup
						,'사장', 6
						,'부장', 5
						,'과장', 4
						,'대리', 3
						,'주임', 2
						,1
					)
					desc;
		----------------------------------------------
		order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case 가 끌어 안아서 다른 형태로 바꾼 것이다.
		----------------------------------------------
		정렬 시 사장은 1로 보고, 부장은 2로 보고, 과장은 3으로 보고, 대리는 4로 보고, 주임은 5로 보고 기타는 6으로 보고 오름차순으로 정렬한다. 즉, 직급을 정수로 바꿔서 정렬을 한 것이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49> employee 테이블에서 직원번호, 직원명, 입사일(년-월-일(요일) 시분초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		, emp_name
		, to_char(hire_date,'YYYY-MM-DD(DAY) Q AM HH:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
		, to_char(hire_date,'YYYY-MM-DD(DAY) HH24:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	----------------------------------------------
	to_char(날짜또는숫자컬럼명, '리턴시원하는문자패턴')
	----------------------------------------------
		지정한 날짜 또는 숫자를 원하는 출력문자패턴 으로 바꾸어 주는 변환함수의 일종
		리턴시 원하는 문자패턴
			YYYY   => 년도 4자리
			MM     => 월 2자리
			DD     => 일 2자리
			AM HH  => 오전|오후 1~12사이의 시간
			HH24   => 0~23 사이의 시간
			MI     => 0~59 사이의 분
			SS     => 0~59 사이의 초
			DAY    => 영문 요일 풀네임
			DY     => 영문 요일 약어
			Q      => 1~4 사이의 분기

	----------------------------------------------
	to_char(hire_date,'YYYY-MM-DD')
	----------------------------------------------
		hire_date 컬럼안의 데이터를 년-월-일 패턴의 문자열로 바꾸어 리턴하라.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49-1> employee 테이블에서 직원번호, 직원명, 입사일(X년-X월-X일(요일) X분기 X시X분X초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	1999년-12월-25일(화) 4분기 11시 10분 22초

	select
		emp_no
		,emp_name
		,to_char(hire_date, 'YYYY')||'년'
		|| to_char(hire_date, 'MM')||'월'
		|| to_char(hire_date, 'DD')||'일'
		|| to_char(hire_date, '(DY)' , 'NLS_DATE_LANGUAGE = Korean')
		|| to_char(hire_date, 'AM HH')||'시'
		|| to_char(hire_date, 'MI')||'분'
		|| to_char(hire_date, 'SS')||'초'
	from
		employee;
	----------------------------------------------
	select
		emp_no
		, emp_name
		, to_char(hire_date,'YYYY"년-"MM"월-"DD"일" (DY) Q"분기" HH"시"MI"분"SS"초"' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<50> employee 테이블에서 직원번호, 직원명, 나이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		, emp_name
		, to_number(  to_char(sysdate,'YYYY')  )
		 - to_number(
		  case
 			substr(jumin_num,7,1) when '1' then '19'
 			when '2' then '19' else '20' end ||substr(jumin_num,1,2)
		 ) + 1  ||'세'                 "나이"
	from
		employee;
	----------------------------------------------
	select
		emp_no
		, emp_name
		, 현재년도
		  -
			출생년도+1||'세'
	from
		employee;
	----------------------------------------------
	to_number(숫자문자내장된컬럼명) => 컬럼명 안의 숫자 문자를 숫자로 변경하는 변환함수
	----------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<51> employee 테이블에서 직원번호, 직원명, 근무년차를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		,emp_name "직원명"
		, 오늘날짜에서 입사일날짜까지의 차이를 일수로 구하고 365 나눈 후 소수 첫째 자리에서 무조건 올림 "근무년차"
	from
		employee;
	----------------------------------------------
	select
		emp_no                                       "직원번호"
		, emp_name                                   "직원명"
		, ceil((sysdate - hire_date)/365)||'년차'     "근무년차"
	from
		employee;
	----------------------------------------------
	오라클은 날짜-날짜 의 결과값은 날짜차이만큼의 일수이다.
	----------------------------------------------
	ceil(~)  => 소수 첫째 자리에서 무조건 올림해서 리턴하는 수학 함수의 일종이다.
	floor(~) => 소수 첫째 자리에서 무조건 내림해서 리턴하는 수학 함수이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		,emp_name "직원명"
		, floor(
		  (
			to_number(to_char(sysdate,'YYYY'))
		 	- to_number(
		  	case
 					substr(jumin_num,7,1) when '1' then '19'
 					when '2' then '19' else '20'
				end ||substr(jumin_num,1,2)
		 		) + 1
		 	) * 0.1
		 )  ||'0대'     "연령대"
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53> employee 테이블에서 직원번호, 직원명, 100일잔치날짜를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		, emp_name "직원명"
		, to_char(
				to_date(
					case substr(jumin_num,7,1) when '1' then '19'
					when '2' then '19' else '20' end||substr(jumin_num,1,6)
					, 'YYYYMMDD'
				) + 100
				, 'YYYY-MM-DD'
			)                           "100일잔치날짜"
	from
		employee;

=> 여기서 요일 추가하려면 (DAY) 넣으면됨. 한글형식이려면 'NLS_DATE_LANGUAGE = Korean' 붙여넣으면 됨.
	----------------------------------------------
	날짜+정수   => 날짜에 정수만큼의 일수를 더한 날짜를 리턴.
	날짜-정수   => 날짜에 정수만큼의 일수를 뺸 날짜를 리턴.
	날짜1-날짜2 => 날짜1 과 날짜2 까지의 차이를 일수로 리턴. 일수 양수가 날짜1이 날짜2 보다 큰거다
	----------------------------------------------
	날짜1+날짜2 => 이런거 없다.......
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53-1> 개강일이 2021년5월12일 이고 종강일이 2021년11월10일 이다. 며칠 동안 학원 생활을 하나?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		to_date('20211110', 'YYYYMMDD')
		-
		to_date('20210512', 'YYYYMMDD')
	from
		dual;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<54> employee 테이블에서 직원번호, 직원명, 현재나이, 입사일당시나이 를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                     "직원번호"
		,emp_name                  "직원명"
		,to_number(to_char(sysdate, 'YYYY'))
			- to_number(
				case substr(jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
				||substr(jumin_num,1,2)
			) + 1 ||'세'               "현재나이"
		,to_number(to_char(hire_date, 'YYYY'))
			- to_number(
				case substr(jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
				||substr(jumin_num,1,2)
			) + 1 ||'세'               "입사일당시나이"
	from
		employee;
	----------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<55> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올생일날(년-월-일), 생일까지남은일수 를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                                                 "직원번호"
		, emp_name                                             "직원명"
		, jumin_num                                            "주민번호"
		, 올해생일날짜-지금이시각날짜 = 다가올 생일날
		, 생일까지남은일수
	from
		employee;
	----------------------------------------------
	select
	  emp_no                                                 "직원번호"
	  , emp_name                                             "직원명"
	  , jumin_num                                            "주민번호"

		,case when
				to_date(
	    		to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
					, 'YYYYMMDD'
	  		)
				-
				sysdate
				>=0
			then	--올해 생일을 년-월-일 로 리턴하는 식
				to_char(
						to_date(
								to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
								, 'YYYYMMDD'
						)
						,'YYYY-MM-DD'
				)
			else  --내년 생일을 년-월-일 로 리턴하는 식
				to_char(
						to_date(
								to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
								, 'YYYYMMDD'
						)
						,'YYYY-MM-DD (dy)'
				)
		end    "다가올생일날"
		,ceil(
		case when
				to_date(
					to_number(to_char(sysdate,'YYYY'))||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
				>=0
		then
				to_date(
				to_number(to_char(sysdate,'YYYY'))||substr(jumin_num,3,4)
				, 'YYYYMMDD'
				)
				-
				sysdate
		else
				to_date(
					to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
		end
		)
		 "생일까지남은일수"
	from
	  employee
	order by 5 asc;  -- order by "생일까지남은일수" asc; 별칭으로 써도 적용된다.
	--------------------------------
	생일까지 남은일수 계산 방법
	--------------------------------
		만약 올해생일-지금날짜 값이 양수면 생일이 안지났으므로 올해생일날짜-지금날짜면 된다.
		만약 올해생일-지금날짜 값이 음수면 생일이 지났으므로 내년생일날짜-지금날짜면 된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<56> employee 테이블에서 직원번호, 직원명, 직급, 연봉(xxx,xxx,xxx만원) 를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		  emp_no                                    "직원번호"
		  , emp_name                                "직원명"
		  , jikup                                   "직급"
			, to_char(salary, '999,999,999')||'만원'  "연봉"
	from
		employee;
	-------------------------------------------------------
	to_char(salary, '999,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 `,` 를 삽입해서 문자로 리턴하기
	                                  만약 각 9 자리에 대응하는 숫자 없으면 화면에 출략이 안된다.
	-------------------------------------------------------
	to_char(salary, '099,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 `,` 를 삽입해서 문자로 리턴하기
																		맨앞에 0이 있으면 그자리가 비면 0이 대체된다. 따라서 나머지도 9이어도 다 0으로 대체가 된다.
	-------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<57> employee 테이블에서 수요일에 태어난 직원을 검색하라 (새로추가)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
to_char(
		to_date(
			case substr(jumin_num,7,1) when '1' then '19'
			when '2' then '19' else '20' end||substr(jumin_num,1,6)
			, 'YYYYMMDD'
		)
		, 'DY'
		, 'NLS_DATE_LANGUAGE = Korean'
	) = '수';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'DAY'
		,'NLS_DATE_LANGUAGE = Korean'
)
= '수요일';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'D'
		,'NLS_DATE_LANGUAGE = Korean'
)
= '4';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<58> employee 테이블에서 70년대생 남자 직원을 검색하라 (새로추가)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select * from employee
	where
		substr(jumin_num,1,1) = '7'
		and
		substr(jumin_num,7,1) = '1' ;
	--------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<59> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
	(substr(jumin_num,1,1) = '6'
	or
	substr(jumin_num,1,1) = '7'
	)
	and
	(substr(jumin_num,7,1) = '1'
	or
	substr(jumin_num,7,1) = '3'
	);




■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<> 오라클의 자주 사용되는 숫자함수 예를 보여주세요
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------------------
abs( n )
-----------------------------------------------
	▶숫자 n의 절대값을 변환.
-----------------------------------------------
floor( n )
-----------------------------------------------
	▶숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서 제일 가까운 정수를 반환.
	▶좌표계에서 쿵 찍어서 왼쪽 정수값
-----------------------------------------------
ceil( n )
-----------------------------------------------
	▶숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서 제일 가까운 정수를 반환.
	▶좌표계에서 쿵 찍어서 오른쪽 정수값
-----------------------------------------------
round( n, m )
-----------------------------------------------
	▶숫자 n에서 소수 m+1 자리에서 반올림한 수 리턴
-----------------------------------------------
trunc( n, m )
-----------------------------------------------
	▶숫자 n 에서 소수 m+1 자리부터 버림.
-----------------------------------------------
sign( n )
-----------------------------------------------
	▶n>0 면 1, n<0 면 -1, n=0 면 0을 반환.
-----------------------------------------------
mod( n, m )
-----------------------------------------------
	▶n / m 후 나머지 값을 반환.
-----------------------------------------------
power( n, m )
-----------------------------------------------
	▶n의 m승을 반환.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<60> 오라클의 자주 사용되는 문자함수 예를 보여주세요
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
chr( n )
	▶정수 n을 ascii(아스키) 문자기호로 리턴한다.
upper( s )
	▶문자열 s를 대문자로 변환시켜 리턴한다.
lower( s )
	▶문자열 s를 소문자로 변환시켜 리턴한다.
length( s )
	▶문자열 s의 길이를 리턴한다.
substr( s, n1, n2)
	▶문자열 s 에서 n1 번째 자리부터 n2개 까지의 문자를 리턴한다.
	▶n2 생략 시 마지막 까지 문자를 리턴한다.
	▶n1 이 0일 경우 1로 바꿔 실행된다.
	▶자리수는 n1>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 샘한다.
	---------------------------------------------------------
	select substr( 'You are not alone', 9, 3 ) from dual;
	select substr( 'You are not alone', 0, 5 ) from dual;
	select substr( 'You are not alone', 5 ) from dual;
	select substr( 'You are not alone', -5, 2 ) from dual;
	select substr( 'You are not alone', 5, 0 ) from dual;

trim( s )
	▶문자열 s1의 맨좌우측의 공백을 제거하여 리턴한다.
    제거 후 또 있으면 계속 제거 후 리턴한다.
