■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<1> 데이터베이스?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류하여 정리해 놓은 [자료의 집합]을 말한다.
데이터베이스 조건( 입.기 )  // 입: 입사시험문제. // 기 : 정보처리 기사 시험문제.
	실시간 접근성, 지속적인 변화(=최신의 정보가 정확하게 저장), 동시 공유 등

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<2> RDBMS (Relational Database Management System, 관계형 데이터베이스 관리 시스템) 란?	(입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●데이터가 [컬럼(column=열)]과 [로우(Row=행)]로 이루어진 [테이블]에 저장되며, [테이블]들 사이에 관계를 설정하여
 관리하는 SW 또는 시스템을 말한다.

●RDBMS 제품의 종류
	Oracle 사의 Oracle		=> 대기업용. 현재 대기업 공기업 프로젝트에 제일 많이 사용하고 있음.
	MS 사의 MS-SQL		=> 대기업용
	Sun Microsystems 사의 MYSQL => 중소기업용
	Sybase
	DB2 등
●고객의 정보를 저장하는 테이블 custumer가 있다면 아래와 같은 구조로 데이터를 저장하여 관리한다.
면 아래와 같은 구조로 데이터를 관리한다.
---------------------------------------------------------------------

		custumer                             => 테이블명
------------------------------------------
고객번호       고객명      주소       전화번호         =>column 명
------------------------------------------
1              저팔계      서울      02-1234-1234       =>row(행)
------------------------------------------
2              사오정      부산      02-2345-2345       =>row(행)
------------------------------------------
3              손오공      제주      02-3456-3456       =>row(행)
------------------------------------------
↓              ↓          ↓            ↓
column      column      column      column
(컬럼)       (컬럼)       (컬럼)        (컬럼)
(열)          (열)         (열)          (열)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<3> SQL(Structured Query Language) 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS에 접근해서 데이터의 [입력], [수정], [삭제], [검색] 하는 등의 기능을 가진 RDBMS 관리 언어 이다.
  <참고> DB, 즉 오라클을 배운다라는 말은 SQL 언어를 배우는 것과 동일하다.
●특징
	▶[절차적 언어]가 아닌 [구조적 언어]이다.  //솔루션 회사에서 물어볼 수 있음.
	   <참고>절차적(procedural) 언어 (입)
		▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. (C, Java 등)
	   <참고>구조적(structured) 언어 (입)
		▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만
                      	   나열하만 로직이 처리되는 언어. (SQL...)

	// Oracle ex) 구조적 언어
	select count(*) from employee


●SQL 종류 ( 기, 입)
	--------------------------------
	DDL(Data Definition Language = 데이터 정의 언어)
	--------------------------------
		▶객체를 생성, 수정, 삭제 등의 작업을 한다.
		----------------------
		CREATE => 객체 생성
		ALTER => 객체 수정. <조심>update가 아니다. 시험문제에 자주 등장.
		DROP => 객체 삭제
		기타 등등
		----------------------
		<주의>오라클에서 객체란 이름을 가지고 저장되는 놈들을 객체라 부른다. 자바의 객체와 다르다.
		<참고>오라클에서 객체는 [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등 을 말한다.

	--------------------------------
	DML(Data Manipulation Language = 데이터 처리 언어)
	--------------------------------
		▶테이블 안의 데이터를 입력, 수정, 삭제, 검색 등의 작업을 한다.
		--------------------------------
		INSERT => [행단위]의 데이터 입력
		UPDATE => [셀 단위]의 데이터 수정/삭제
		DELETE => 행 단위의 데이터 삭제
		SELECT => n행 m열의 데이터 검색 SQL 공부의 90%차지한다. DB 실력은 SELECT 구사 능력이다.
		기타 등등
		--------------------------------
		<문> 셀에 들어있는 데이터를 제거하는 SQL구문은?  => UPDATE !!!	학원 프로젝트에 주도적으로 참여 했는지 알 수 있는 질문.
		<문> 행을 제거하는 SQL구문은?  => DELETE !!!

	--------------------------------
	DCL(Data Control Language = 데이터 제어 언어)
	--------------------------------
		COMMIT		=> 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정
		ROLLBACK	=> 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소
		GRANT		=> 접근제어, 작업권한허용
		REVOKE		=> 권한제거



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<4>트랜잭션(Transaction) 이란 뭡니까? (입.기.실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위를 말한다.	//포괄적
●트랜잭션은 주로 입력 또는 수정 또는 삭제 SQL 구문 실행 시 설정한다.		//실무적
●트랜잭션이 걸린 작업은 가상 작업이 되고 rollback 를 실행하면 모두 취소되고 commit 를 실행하면
  가상작업이 모두 실제로 작업으로 인정된다.
●<주의>트랜잭션은 의도를 가지고 설정하는 것이다.
●<주의>트랜잭션이 없는 작업은 N가지 이상의 다양한 결과로 진행 될 수 있다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<5>오라클에서 [계정] 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●오라클에 접속하는 사용자를 말한다.
●사용자 마다 권한을 다르게 줄 수 있다.
●오라클은 다수의 클라이언트에게 동시에 정보를 제공하는 서버이므로 서버의 특징인 계정과 암호를 가지고 있다.
--------------------------------
<참고>서버(SERVER)?
--------------------------------
	다수의 클라이언트에게 동시에 정보를 제공하는 H/W 나 S/W 를 말한다.

●오라클 계정의 종류
	-------------------------------------------------------------------
	SYS		-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다. 반지의 제왕!
	-------------------------------------------------------------------
	SYSTEM		-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다.
			단 [데이터베이스] 생성 권한이 없다.
	-------------------------------------------------------------------
	SCOTT		-> 오라클 설치 시 기본적으로 만들어지는 계정. 권한이 거의 없다.
	-------------------------------------------------------------------
	생성 계정		-> 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정된다.
			주로 SYS, SYSTEM 계정 또는 SYS, SYSTEM 계정과 동일한 권한을 가진 계정이 만든다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<6>데이터베이스 차원에서 스키마 (Schema) 란 뭡니까? (입, 기, 실) 대형 솔루션 회사 입사 시험 타겟!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[데이터베이스의 구조]에 대한 정의와 제약조건 등을 기술한 [명세서]를 말한다.	// 데이터 베이스 한정 정의.
●[계정]이 생성한 모든 [객체]들을 의미 한다. (오라클 객체=>테이블, 뷰, 인덱스, 프로시저, 트리거 등)
  객체들이 DB 구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.
●[kim] 계정이 객체(테이블,인덱스,뷰 등)들을 생성했다면 이 객체들 모두를 가리켜 [kim 스키마]라고 한다.
●생성되는 객체는 [계정명.객체명] 형식으로 저장된다.

<예>abc 계정으로 로그인해 => employee 테이블 생성.  abc.employee 형태로 저장됨.
<예>kim 계정으로 로그인해 => employee 테이블 생성.  kim.employee 형태로 저장됨.
<예>kim 계정으로 로그인해 => employee 테이블 생성.  kim.employee 형태로 저장 안됨. 이미 있으니까.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<7>데이터베이스 차원에서 테이블(table) 란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS 에서 데이터가 실질적으로 저장되는 [논리적 장소(=S/W 적인 장소)]를 말한다.
●[컬럼(column=열)]과 [로우(Row=행=record)]로 구성되어 있다.
●테이블은 이름가지고 저장되는 객체의 한 종류이다.
●개발자 입장에서 제일 손이 많이 가는 객체이다.
●테이블에 데이터를 입력하는 SQL 이 insert 이다.
●테이블에 데이터를 수정하는 SQL 이 update 이다.
●테이블에 데이터를 삭제하는 SQL 이 delete 이다.
●테이블에 데이터를 검색하는 SQL 이 select 이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<8>테이블(table) 을 생성하는 SQL 구문의 형식은?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

-------------------------------------
CREATE TABLE 테이블명(
		컬럼명1		자료형		제약조건
		, 컬럼명2		자료형		제약조건
		, ~
		, 컬럼명n		자료형		제약조건
);
-------------------------------------
CREATE TABLE 테이블명(
		컬럼명1		자료형		제약조건,
		컬럼명2		자료형		제약조건,
		 ~         ~           ~	,
		컬럼명n		자료형		제약조건
);
-------------------------------------
	-------------------------------------
	자료형(Data type) => 테이블의 컬럼에 입력될 데이터의 유형을 말한다. 문자형, 숫자형, 날짜형 등이 있다.
	-------------------------------------
	제약조건 => 입력되는 데이터의 입력 가능 조건을 말한다. 제약조건에 위배되는 데이터는 삽입될 수 없다
			제약조건이 생략되면 데이터가 입력되지 않을 경우 null 이 저장된다.
	-------------------------------------
	<주의>테이블명, 컬럼명 제작 규칙
			▷영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다.
			▷30자를 초과할 수 없다. SQL 예약어는 사용할 수 없다.
			▷하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야한다.
			▷테이블명, 컬럼명, 제약조건명을 " 로 감싸거나 " 없이 그냥 써도된다.
			▷▷테이블명, 컬럼명 은 가독성 있게 주는 것이 제일 중요하다.

	자바에서 " 와 ' 가 언제 사용되는지 설명?
	String 형 ""
	char 형 ''

	String str1 = "산";
	String str2 = '산';	// '' 때문에 에러/ 변수선언이 먼저이기 때문에 String 이기때문에 ""로 바꿔주어야 맞다.
	char str3 = '산너머';  // char 형이라서 길이가 세글자라서 에러.
	String str4 = '산너머'; // "" 로 안써서 에러
	// 셋다 들어간 데이터가 잘못된것이다.

	오라클에서 " 와 ' 가 언제 사용되는지 설명?

	자바스크립트에서 " 와 ' 가 언제 사용되는지 설명?


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<9> 오라클에서 자료형의 종류는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
오라클은 대문자가 원칙이지만 소문자도 상관은 없음.

-------------------
CHAR(s)
-------------------
	▶고정길이 문자열 저장. s는 byte수를 의미.
	▶설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
	▶설정 크기보다 입력 문자 크기가 크면 ? 행 자체가 입력되지 않는다.
	▶<예>CHAR(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
			<참고>영문 1자는 1byte 차지, 한글 1자는 2byte차지.
	▶최대크기는 2000Byte 이다.
	▶CHAR 는 CHAR(1) 과 동일. ex) 성별 표현. m/w 두가지만. 표현하기 때문.

-------------------
VARCHAR2(s)
-------------------
	▶가변길이 문자열 저장. s 는 byte 수를 의미.
	▶설정 크기보다 입력문자 크기가 작으면 크기가 자동으로 줄어든다. (DB 서버 부담은 증가)
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<예>VARCHAR2(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
	▶보통 테이블을 설계할 때는 CHAR 타입보다는 VARCHAR2 타입을 많이 사용한다.
		임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문이다.
	▶최대크기는 4000Byte 이다.
	▶VARCHAR2 만 쓸수는 없다. // CHAR랑 혼동하지 말것!!

-------------------
NUMBER(p,s)
-------------------
	▶정수형 또는 실수형 숫자 저장.
	▶p(precision) => 전체 자릿수(1~38). s(scale) => 소수점이하 자릿수(-84~127)
	▶s 생략 시 디폴트 0 설정.
	▶NUMBER 는 즉 p(precision), s(scale) 모두 생략 시 정수, 소수점이하 자릿수 합쳐 40자리 까지 저장.
	▶소수점 자리수가 넘치면 반올림하고 정수 자리수가 넘치면 오류가 난다. 즉, 행 입력이 안된다.
	--------------------------------------------------
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.56 저장하면? 1234.56 저장.
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.567 저장하면? 1234.57 저장. 반올림 한 후 소수점 2자리 까지 저장.
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 12345.6 저장하면? 저장오류(행 자체가 못들어감). 정수 자릿수 부족으로 오류
	--------------------------------------------------
	▶<예> NUMBER(3) 라고 지정한 컬럼에 123 지정하면? 123 저장
	▶<예> NUMBER(3) 라고 지정한 컬럼에 123.4 지정하면? 123 저장. 소수점 1자리에서 반올림해서 저장.
	▶<예> NUMBER(3) 라고 지정한 컬럼에 1234 지정하면? 저장오류. 정수부문 자릿수 부족으로 오류.


-------------------
DATE
-------------------
	▶[년, 월, 일, 시, 분, 초] 저장.
	▶저장 범위는 BC 4712년 1월 1일~9999년 12월 31일.
	▶<참고>보통 날짜형 데이터는 SQL 문장에서 [TO_CHAR] 변환함수, [TO_DATE] 변환함수와 같이 사용된다.

	▶<참고>2021년06월11일 부터 ▶2021년12월25일 까지 남은 일수 검색하는 SQL 구문 작성?
		---------------------------------------------------
		select to_date('2021225', 'YYYYMMDD')-to_date('20210611', 'YYYYMMDD') from dual
		---------------------------------------------------
	▶<참고>오늘 날짜를 예쁘게 연-월-일 로 검색하는 SQL 구문작성?
		---------------------------------------------------
		select to_char(sysdate. 'YYYY-MM-DD') from dual
		---------------------------------------------------
	▶<참고>변환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER] 와 같이 사용된다.

------------------
<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE 도 있다.
<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.
------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<10> 오라클에서 제약조건의 종류는? (입, 기, 실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

----------------
not null
----------------
	▶반드시 데이터가 입력돼야 한다. 비지마! 필수입력 데이터 니까!

----------------
unique
----------------
	▶중복되는 데이터는 입력 불가능하다. 중복마!
	▶<예>주민번호, 전화번호, 직원번호 등등
	▶일반적으로 또는 관용적으로, 실무적으로 unique 을 가진 컬럼은 not null 도 같이 들어간다.

----------------
default
----------------
	▶데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
	▶<예>회원가입할 때 가입날짜를 입력하지 않아도 그 당일날짜가 저장되는 경우.

----------------
check
----------------
	▶지정한 데이터만 입력 가능하다.
	▶<예>성별 입력 시 남 또는 여 만 입력되는 경우

----------------
Primary key(PK)
----------------
	▶not null, unique 의 제약조건 성질을 가진다. 즉 행과 행을 구분할 수 있는 유일한 데이터가 입력된다.
	▶차후에 foreign key에 의해 참조 당할수도 있다.
	▶하나의 테이블에 하나의 Primary key만 설정 할 수 있다. 즉 테이블당 0~1개만 줄 수 있다.
	▶[기본키], [주키] 라고도 한다.

----------------
foreign key(FK)
----------------
	▶Primary 키에 존재하는 데이터만 삽입될 수 있다. (=Primary 키를 참조하는 키다.)
	▶<주의>예외적으로 null 값은 입력 가능하다. 즉, 데이터가 입력되지 않을수도 있다.
	▶하나의 테이블에 0개 이상의 foreign key를 설정할 수 있다.
	▶table과 table간의 관계를 설정하는 키다.
	▶[참조키], [외래키], [관계키], [종속키] 라고도 한다.


(예시)

									employee
	=================================================
	e_name    dep_name    salary    jikup   jumin_num
	=================================================
	사오정     관리부     5000      대리    901225-1234543
	저팔계     영업부     6000      과장    ~
	손오공     자재부     7000      부장    ~
	사오정     관리부     5000      대리    901225-1234543



	PK							employee
	=================================================
	e_no    e_name    dep_name    salary    jikup
	=================================================
	1       사오정     관리부     5000      대리
	2       저팔계     영업부     6000      과장
	3       손오공     자재부     7000      부장
	4				사오정			관리부			5000			대리


(예시)

	dept
=====================================================
dep_no(PK)     dep_name
=====================================================
10             관리부
20             자재부
30             홍보부
40             사업부


                  employee
===============================================================
e_no(PK)     e_name    dep_no(FK)    salary  jikup     mgr_e_no(FK)
===============================================================
1         사오정       10            5000     대리       3
2         저팔계       20            6000     과장       3
3         손오공       30            7000     부장       null
4         사오정       40            5000     대리       2


            customer
=====================================================
c_no(PK)     c_name    phone  e_no(FK)
=====================================================
1         사오순        ~     2
2         저팔순        ~     4
3         손오순        ~     1
4         사오순        ~     2


OX문제 20210611.md 참고.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<11> 시퀀스(sequence) 가 뭡니까?	(입50%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[고유 일련 번호]를 생성해서 제공하는 객체이다. 일종의 [일련 번호 생성기] 이다.
●주로 하나의 테이블에서 PRIMARY KEY 로 지정된 컬럼명에 입력될 [일련 번호] 값을 생성한다.
●<비유>은행에서 번호표 뽑는 기계와 동일한 기능을 가진다.
--------------------------
●시퀀스 생성 SQL 구문
--------------------------
	-----------------------------------
	create sequence 시퀀스명
		start with 시작값
		increment by 증가값
		minvalue 최소값
		maxvalue 최대값;
	-----------------------------------
	예
	-----------------------------------
	create sequence sq_emp
		start with 1
		increment by 1
		minvalue 1
		maxvalue 9999;
	-----------------------------------
	create sequence sq_emp
		start with 999
		increment by -1
		minvalue 1
		maxvalue 9999;
	-----------------------------------
--------------------------
●증가된 새 일련번호 얻는 SQL 구문
--------------------------
	시퀀스명.nextval
--------------------------
●마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
--------------------------
	시퀀스명.curval
--------------------------
●시퀀스 삭제 SQL 구문
--------------------------
	drop sequence 시퀀스명;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<12> 오라클을 연습하려면 어떤 SW를 설치해야 합니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다.
<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다,
	▶IP            => ip주소 또는 localhost
	▶사용자        => system
	▶암호          => 설정암호
	▶SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<13> system 계정으로 접속하니 쓸 때 없는 테이블이 많아 번거롭네요.
     system 계정과 동일한 권한을 가지는 새로운 계정을 만들려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
	create user king  identified by k123;
② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
	grant connect,resource,dba to king;
③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다,
	●IP            => 127.0.0.1 또는 localhost
	●사용자        => king
	●암호          => k123
	●SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<14>아래 고객 요구사항에 맞는 테이블을 만들면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	부서를 관리하고 싶어요.
		관리하고 싶은 정보는 부서명, 부서 위치 입니다.
	-----------------------------------------------------------------
	직원정보를 관리하고 싶어요
		관리하고 싶은 정보는 직원명, 직급, 입사일, 소속부서명, 연봉, 주민번호, 전화번호, 연봉등급, 직속상관명 입니다.
	-----------------------------------------------------------------
	고객정보를 관리하고 싶어요
		관리하고 싶은 정보는 고객명, 전화번호, 주민번호, 담당직원명 입니다.
	-----------------------------------------------------------------
	연봉등급을 관리하고 싶어요
		관리하고 싶은 정보는 연봉등급, 등급별최소연봉, 등급별최대연봉
	-----------------------------------------------------------------

	SQL_02_teacher0615.sql 에 정답 있음.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<15> employee 테이블에서 모든 컬럼, 모든행의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	select * from employee;
	-----------------------------------------------------------------
	select emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num mgr_emp_no from employee;
	-----------------------------------------------------------------
	select
		emp_no
		, emp_name
		, dep_no
		, jikup, salary
		, hire_date, jumin_num
		, phone_num
		, mgr_emp_no

	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<16> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 컬럼의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no, emp_name, jikup, salary, hire_date
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<17> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 을 검색하면서
	별칭(=alias)을 즉, 헤더를 사원번호, 직원명, 직급, 연봉, 입사일로 하고
	연봉에 '만원' 이란 문자를 붙여 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-----------------------------------------------------------------
	select
		emp_no             as "직원번호"
		, emp_name         as "직원명"
		, jikup            as "직급"
		, salary||'만원'   as "연봉"
		, hire_date        as "입사일"
	from
		employee;
	-----------------------------------------------------------------
		<참고> as 생략이 가능하다.
		<참고> 별칭에 공백이 없으면 "" 도 생략이 가능하다. 그치만 무조건 사용하는것이 좋다. 일단 한놈만 패자...
		<참고> 오라클에서 연결 연산자는 + 가 아니라 || 이다. 자바와 다르다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액을 검색하면? (세금은 연봉의 12%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	select
		emp_name               as "직원명"
		, jikup                as "직급"
		, salary*0.12||'만원'   as "세금"
		, salary*0.88||'만원'   as "실수령액"
	from
		employee;
	-----------------------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<19> employee 테이블에서 직급을 중복없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select distinct jikup from employee;
	-----------------------------------------------
	select unique jikup from employee;
	-----------------------------------------------
	select distinct(jikup) from employee;
	-----------------------------------------------
	select unique(jikup) from employee;
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<20> employee 테이블에서 부서번호와 직급을 중복 없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select distinct dep_no, jikup from employee;
	select unique dep_no, jikup from employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<21> employee 테이블에서 연봉이 3000 이상인 직원을 검색해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary>=3000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<22> employee 테이블에서 연봉 오름차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by salary asc;
	-----------------------------------------------
	select * from employee order by salary ;
	-----------------------------------------------
	select * from employee order by 5 asc; -- 컬럼명 위치번호.
	-----------------------------------------------
	select * from employee order by 5 ;     -- asc 생략 가능.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<23> employee 테이블에서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  -----------------------------------------------
	select * from employee order by salary desc;  -- 내림차순
  -----------------------------------------------
	select * from employee order by 5 desc;
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<24> employee 테이블에서 부서번호 오름차순을 유지하면서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by dep_no asc, salary desc;
	-----------------------------------------------
	select * from employee order by dep_no , salary desc;  -- asc 생략 가능하지만 혼동될 가능성이 높다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<25> employee 테이블에서 직급이 높은 순서 나열해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by jikup desc;
	-----------------------------------------------
	select * from employee order by jikup asc;
	-----------------------------------------------
	위 답은 모두 잘못된것임.
	직급순서는 인간이 생각하는 기준이지 오라클의 단순한 정렬개념하고는 다르다.
	추후 조건문을 써서 정렬의 기준을 바꾸어야 답이 나온다. 나중에 합시다.
	그래도 알고 싶다면 아래가 답이다.
	-----------------------------------------------
	select * from employee order by decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4), salary desc; -- 직급순서와 연봉순서. 복합.
	-----------------------------------------------
	<명심> 고객의 요구 사항을 보고 select 문을 작성하는것도 중요하지만
	이미 작성된 select 문을 보고 고객의 요구 사항을 알아내는 것도 중요하다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<26> employee 테이블에서 부장만 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup=='부장';   -- 오라클은 '==' 은 없다.
	select * from employee where jikup='부장';    -- 이것이 정답.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<27> employee 테이블에서 20번 부서의 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<28> employee 테이블에서 20번 부서 또는 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 or jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<29> employee 테이블에서 과장 중에 연봉 3400 이상을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary>=3400 and jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<30> employee 테이블에서 실수령 액이 4000만원이상 받는 직원을 검색하면? 단, 세금이 12% 라고 가정하자.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary*0.88>=4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서 부서번호가 내림차순이면서
	사장이 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by salary*0.12 desc, dep_no desc where jikup!='사장';
	select * from employee where jikup != '사장' order by salary*0.12 desc , dep_no desc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<32> employee 테이블에서 20번 부서 중에 연봉 2000~3000 사이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and salary>=2000 and salary<=3000;
	select * from employee where dep_no=20 and salary between 2000 and 3000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<33> employee 테이블에서 직속 상관이 없는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<34> employee 테이블에서 직속 상관이 있는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is not null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<35> 오라클 4대 천왕?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	내장함수               => 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴한다.
	join (조인)            => 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
	subquery (서브쿼리)    => SQL 구문안의 select 문
	group by              => 통계관련 작업

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<36> employee 테이블에서 [최소 연봉]. [최대 연봉], [평균 연봉], [연봉총합], [총인원수]을 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select

  	min( salary )    as "최소연봉"  -- salary 컬럼에서 최소값을 리턴
  	,max( salary )   as "최대연봉"  -- salary 컬럼에서 최대값을 리턴
  	,avg( salary )   as "평균연봉"  -- salary 컬럼에서 평균값을 리턴.
                                 -- <조심>avg 사용 시 null 있으면 더할때 빠지고 나누는 개수에서도 빠진다.
  	,sum( salary )   as "연봉총합"  -- salary 컬럼에서 총합을 리턴.
  	,count( salary ) as "총인원수"  -- count(*) 는 총행의 개수
	from
  	employee;
	-----------------------------------------------------
	min, max, avg, sun, count 함수들을 [그룹함수] 또는 [통계함수] 라고 부르기도 한다.
	그룹지어서 연산을 하는 함수이기 때문이다.
	그룹함수들은 주로 group by 와 같이 많이 사용한다.
	-----------------------------------------------------
	min, max, avg, sun, count 함수들은 null 값은 제외하고 계산한다.
	-----------------------------------------------------
	count(컬럼명) => 컬럼안의 null 아닌 데이터의 개수를 리턴한다.
	count(*)     => 행의 개수를 리턴한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<37> 아래 SQL 구문은 무슨 문제의 답인가?
     select count(emp_no) from customer;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	담당 직원이 있는 고객의 명수는?
	emp_no 컬럼안의 담당 직원의 직원번호이므로 직원번호의 개수는 결국  담당직원이 있는 고객의 명수가 된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<38> 고객을 담당하고 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct emp_no) from customer;
	-----------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39> 직속상관이 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(mgr_emp_no) from employee;
	-----------------------------------------------------
	<주의>mgr_emp_no 컬럼안의 데이터가 뭔지 먼저 파악해야한다. 바로 직속 상관의 직원번호 이다.
	-----------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39-1> 부하직원이 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct mgr_emp_no) from employee;
	-----------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거
	-----------------------------------------------------
	<주의>count에는 업무적 특징(고객요구사항)이 숨어 있어 조심히 날려야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<40> employee 테이블에서 [직원번호], [직원명], [생일월-생일일] 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no                                               "직원번호"
		,emp_name                                            "직원명"
		,substr(jumin_num,3,2)||'-'||substr(jumin_num,5,2)   "생일월일"  -- 세번째에서 두개 출력
	from
		employee;
	-----------------------------------------------------
	*****substr(컬럼명, 복사할시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기. 엄청난 사용빈도를 자랑한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력하면?
	단, 주민번호는 901225-2****** 형태로 출력하세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		cus_no
		,cus_name
		,tel_num
		,substr(jumin_num,1,6)||'-'||substr(jumin_num,7,1)||'******'
		,emp_no
	from
		customer;
	-----------------------------------------------------
	<주의>모든 행이란 말이 나오면 where 절이 없다.
	-----------------------------------------------------
	*****substr(컬럼명, 복사할시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기. 엄청난 사용빈도를 자랑한다.
	-----------------------------------------------------
	|| => 좌우의 문자열을 붙이는 연산자, 즉 연결 연산자이다.
	<조심> 오라클에서 + 는 연결연산자가 아니라 사칙연산자 이다.
	'tom'||'my'
	'tom'||123   -> 	'tom'||'123'   -> 	'tom123'


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<42> customer 테이블에서 고객번호, 고객명, 담당직원번호 를 출력하면?
	단, 담당직원번호가 없으면 null 출력하지 말고 '없음' 으로 표시 하삼!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		cus_no
		,cus_name
		,nvl(emp_no||'','없음')
	from
		customer;
	-------------------------------------------
	nvl( 컬럼명, null값일때 대체데이터)
	-------------------------------------------
	=>컬럼명 안의 데이터가 null 이 아니면 그냥 리턴하고
	null 이면 null값일체 대체데이터 를 리턴하는 [null 처리 내장함수]이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부 를 출력하면?
	단, 직원번호가 있으면 '있음', 없으면 '없음'으로 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
  	cus_no
  	,cus_name
  	,nvl2(emp_no,'있음', '없음')
	from
  	customer;
	-------------------------------------------
	nvl2( 컬럼명, null값아닐때대체데이터, null값일때대체데이터 )
	-------------------------------------------
	=>컬럼명 안의 데이터가 null 이 아니면 null값아닐때 대체데이터 출력하고
 	null 이면 null값일체 대체데이터 를 리턴하는 [null 처리 내장함수]이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<44> employee 테이블에서 직원번호, 직원명, 직급, 성별 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
  	emp_no
  	,emp_name
  	,jikup
  	,case
    	substr(jumin_num,7,1)
    	when '1' then '남'
    	when '3' then '남'
    	when '2' then '여'
    	when '4' then '여'
  	end
	from
  	employee;
	--------------------------------------------------
	select
  	emp_no
  	,emp_name
  	,jikup
  	,case
    	substr(jumin_num,7,1)
    	when '1' then '남'
    	when '3' then '남'
    	else '여'
  	end
	from
  	employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '남'
			when substr(jumin_num,7,1)='3' then '남'
			else '여'
		end
	from
		employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','남'
		,'3','남'
		,'여'
		)
	from
		employee;
	***************************************************
	case ~ end 구문의 패턴 설명
	***************************************************
	<패턴1>--------------------------------------------------
	case 컬럼명
		when 데이터1 then 리턴값1
		when 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	--------------------------------------------------
		컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
		컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
		~
		그외에는 리턴값n 을 리턴하기
	<패턴2>--------------------------------------------------
	case
		when 컬럼명 = 데이터1 then 리턴값1
		when 컬럼명 = 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	--------------------------------------------------
		컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
		컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
		~
		그외에는 리턴값n 을 리턴하기
	--------------------------------------------------
	패턴2 에서 `=` 대신에 필요에 따라 `>=, >, <, <=, !=` 등의 비교연산자도 사용할 수 있다.
	필요에 따라 `else 리턴값n` 는 생략 될 수 있다.
	***************************************************
	decode(~) 구문의 패턴 설명
	***************************************************
		decode(
			컬럼명
			, 비교데이터1, 리턴값1
			, 비교데이터2, 리턴값2,
		  , ~
			, 리턴값n
		)
	--------------------------------------------------
	컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
	컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
	~
	그외에는 리턴값n 을 리턴하기
	--------------------------------------------------
	필요에 따라 리턴값n 는 생략될수 있다.
	--------------------------------------------------
	decode 단점
		=> 같다라는 경우에만 사용된다.
		=> 오라클에서만 사용되는 오라클 전용함수이다. case ~ end 구문은 모든 DB에서 사용가능하다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<45> employee 테이블에서 직원번호, 직원명, 직급, 출생년도(4자리) 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end ||substr(jumin_num,1,2) "출생년도"
	from
		employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','19'
		,'2','19'
		,'20'
		) ||substr(jumin_num,1,2) "출생년도"
	from
		employee;
	---------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<46> employee 테이블에서 직원번호, 직원명, 직급, 출생년대(4자리) 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end ||substr(jumin_num,1,1)||'0년대' "출생년대"
	from
		employee;

	----------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','19'
		,'2','19'
		,'20'
		) ||substr(jumin_num,1,1)||'0년대' "출생년도"
	from
		employee;
	----------------------------------------------
	<참고>
	년도 => 1년 단위
	년대 => 10년 단위

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<47> employee 테이블에서 나이순으로 출력하면? 연장자가 먼저 나오도록.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
	 *
	from
		employee
	order by
		case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end || substr(jumin_num,1,6)

		asc; --asc는 생략 가능하다.
	----------------------------------------------
	아래 처럼하면 안된다. 2000년 생이 먼저 나온다. 2000년 생은 주민번호가 00 으로 시작한다.
	----------------------------------------------
	select * from employee order by jumin_num asc;
	----------------------------------------------
	order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case 가 끌어 안아서 다른 형태로 바꾼 것이다.
	----------------------------------------------
	order by 구문의 패턴
	----------------------------------------------
		----------------------------------------------
		order by 컬럼명|컬럼순서번호|컬럼알리아스 [asc]|desc;
		----------------------------------------------
		컬럼알리아스 = 컬럼을 별칭 헤더.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<48> employee 테이블에서 직급순서대로 정렬하여 모든 컬럼을 보이면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	order by
		case jikup
			when '사장' then 1
			when '부장' then 2
			when '과장' then 3
			when '대리' then 4
			when '주임' then 5 else 6
		end
		asc;
	----------------------------------------------
	--decode로 변경--
	select * from employee
		order by
			decode( jikup
				,'사장', 1
				,'부장', 2
				,'과장', 3
				,'대리', 4
				,'주임', 5
				,6
			)
			asc;
	----------------------------------------------
			select * from employee
				order by
					decode( jikup
						,'사장', 6
						,'부장', 5
						,'과장', 4
						,'대리', 3
						,'주임', 2
						,1
					)
					desc;
		----------------------------------------------
		order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case 가 끌어 안아서 다른 형태로 바꾼 것이다.
		----------------------------------------------
		정렬 시 사장은 1로 보고, 부장은 2로 보고, 과장은 3으로 보고, 대리는 4로 보고, 주임은 5로 보고 기타는 6으로 보고 오름차순으로 정렬한다. 즉, 직급을 정수로 바꿔서 정렬을 한 것이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49> employee 테이블에서 직원번호, 직원명, 입사일(년-월-일(요일) 시분초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		, emp_name
		, to_char(hire_date,'YYYY-MM-DD(DAY) Q AM HH:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
		, to_char(hire_date,'YYYY-MM-DD(DAY) HH24:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	----------------------------------------------
	to_char(날짜또는숫자컬럼명, '리턴시원하는문자패턴')
	----------------------------------------------
		지정한 날짜 또는 숫자를 원하는 출력문자패턴 으로 바꾸어 주는 변환함수의 일종
		리턴시 원하는 문자패턴
			YYYY   => 년도 4자리
			MM     => 월 2자리
			DD     => 일 2자리
			AM HH  => 오전|오후 1~12사이의 시간
			HH24   => 0~23 사이의 시간
			MI     => 0~59 사이의 분
			SS     => 0~59 사이의 초
			DAY    => 영문 요일 풀네임
			DY     => 영문 요일 약어
			Q      => 1~4 사이의 분기

	----------------------------------------------
	to_char(hire_date,'YYYY-MM-DD')
	----------------------------------------------
		hire_date 컬럼안의 데이터를 년-월-일 패턴의 문자열로 바꾸어 리턴하라.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49-1> employee 테이블에서 직원번호, 직원명, 입사일(X년-X월-X일(요일) X분기 X시X분X초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	1999년-12월-25일(화) 4분기 11시 10분 22초

	select
		emp_no
		,emp_name
		,to_char(hire_date, 'YYYY')||'년'
		|| to_char(hire_date, 'MM')||'월'
		|| to_char(hire_date, 'DD')||'일'
		|| to_char(hire_date, '(DY)' , 'NLS_DATE_LANGUAGE = Korean')
		|| to_char(hire_date, 'AM HH')||'시'
		|| to_char(hire_date, 'MI')||'분'
		|| to_char(hire_date, 'SS')||'초'
	from
		employee;
	----------------------------------------------
	select
		emp_no
		, emp_name
		, to_char(hire_date,'YYYY"년-"MM"월-"DD"일" (DY) Q"분기" HH"시"MI"분"SS"초"' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<50> employee 테이블에서 직원번호, 직원명, 나이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		, emp_name
		, to_number(  to_char(sysdate,'YYYY')  )
		 - to_number(
		  case
 			substr(jumin_num,7,1) when '1' then '19'
 			when '2' then '19' else '20' end ||substr(jumin_num,1,2)
		 ) + 1  ||'세'                 "나이"
	from
		employee;
	----------------------------------------------
	select
		emp_no
		, emp_name
		, 현재년도
		  -
			출생년도+1||'세'
	from
		employee;
	----------------------------------------------
	to_number(숫자문자내장된컬럼명) => 컬럼명 안의 숫자 문자를 숫자로 변경하는 변환함수
	----------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<51> employee 테이블에서 직원번호, 직원명, 근무년차를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		,emp_name "직원명"
		, 오늘날짜에서 입사일날짜까지의 차이를 일수로 구하고 365 나눈 후 소수 첫째 자리에서 무조건 올림 "근무년차"
	from
		employee;
	----------------------------------------------
	select
		emp_no                                       "직원번호"
		, emp_name                                   "직원명"
		, ceil((sysdate - hire_date)/365)||'년차'     "근무년차"
	from
		employee;
	----------------------------------------------
	오라클은 날짜-날짜 의 결과값은 날짜차이만큼의 일수이다.
	----------------------------------------------
	ceil(~)  => 소수 첫째 자리에서 무조건 올림해서 리턴하는 수학 함수의 일종이다.
	floor(~) => 소수 첫째 자리에서 무조건 내림해서 리턴하는 수학 함수이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		,emp_name "직원명"
		, floor(
		  (
			to_number(to_char(sysdate,'YYYY'))
		 	- to_number(
		  	case
 					substr(jumin_num,7,1) when '1' then '19'
 					when '2' then '19' else '20'
				end ||substr(jumin_num,1,2)
		 		) + 1
		 	) * 0.1
		 )  ||'0대'     "연령대"
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53> employee 테이블에서 직원번호, 직원명, 100일잔치날짜를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		, emp_name "직원명"
		, to_char(
				to_date(
					case substr(jumin_num,7,1) when '1' then '19'
					when '2' then '19' else '20' end||substr(jumin_num,1,6)
					, 'YYYYMMDD'
				) + 100
				, 'YYYY-MM-DD'
			)                           "100일잔치날짜"
	from
		employee;

=> 여기서 요일 추가하려면 (DAY) 넣으면됨. 한글형식이려면 'NLS_DATE_LANGUAGE = Korean' 붙여넣으면 됨.
	----------------------------------------------
	날짜+정수   => 날짜에 정수만큼의 일수를 더한 날짜를 리턴.
	날짜-정수   => 날짜에 정수만큼의 일수를 뺸 날짜를 리턴.
	날짜1-날짜2 => 날짜1 과 날짜2 까지의 차이를 일수로 리턴. 일수 양수가 날짜1이 날짜2 보다 큰거다
	----------------------------------------------
	날짜1+날짜2 => 이런거 없다.......
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53-1> 개강일이 2021년5월12일 이고 종강일이 2021년11월10일 이다. 며칠 동안 학원 생활을 하나?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		to_date('20211110', 'YYYYMMDD')
		-
		to_date('20210512', 'YYYYMMDD')
	from
		dual;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<54> employee 테이블에서 직원번호, 직원명, 현재나이, 입사일당시나이 를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                     "직원번호"
		,emp_name                  "직원명"
		,to_number(to_char(sysdate, 'YYYY'))
			- to_number(
				case substr(jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
				||substr(jumin_num,1,2)
			) + 1 ||'세'               "현재나이"
		,to_number(to_char(hire_date, 'YYYY'))
			- to_number(
				case substr(jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
				||substr(jumin_num,1,2)
			) + 1 ||'세'               "입사일당시나이"
	from
		employee;
	----------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<55> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올생일날(년-월-일), 생일까지남은일수 를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                                                 "직원번호"
		, emp_name                                             "직원명"
		, jumin_num                                            "주민번호"
		, 올해생일날짜-지금이시각날짜 = 다가올 생일날
		, 생일까지남은일수
	from
		employee;
	----------------------------------------------
	select
	  emp_no                                                 "직원번호"
	  , emp_name                                             "직원명"
	  , jumin_num                                            "주민번호"

		,case when
				to_date(
	    		to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
					, 'YYYYMMDD'
	  		)
				-
				sysdate
				>=0
			then	--올해 생일을 년-월-일 로 리턴하는 식
				to_char(
						to_date(
								to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
								, 'YYYYMMDD'
						)
						,'YYYY-MM-DD'
				)
			else  --내년 생일을 년-월-일 로 리턴하는 식
				to_char(
						to_date(
								to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
								, 'YYYYMMDD'
						)
						,'YYYY-MM-DD (dy)'
				)
		end    "다가올생일날"
		,ceil(
		case when
				to_date(
					to_number(to_char(sysdate,'YYYY'))||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
				>=0
		then
				to_date(
				to_number(to_char(sysdate,'YYYY'))||substr(jumin_num,3,4)
				, 'YYYYMMDD'
				)
				-
				sysdate
		else
				to_date(
					to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
		end
		)
		 "생일까지남은일수"
	from
	  employee
	order by 5 asc;  -- order by "생일까지남은일수" asc; 별칭으로 써도 적용된다.
	--------------------------------
	생일까지 남은일수 계산 방법
	--------------------------------
		만약 올해생일-지금날짜 값이 양수면 생일이 안지났으므로 올해생일날짜-지금날짜면 된다.
		만약 올해생일-지금날짜 값이 음수면 생일이 지났으므로 내년생일날짜-지금날짜면 된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<56> employee 테이블에서 직원번호, 직원명, 직급, 연봉(xxx,xxx,xxx만원) 를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		  emp_no                                    "직원번호"
		  , emp_name                                "직원명"
		  , jikup                                   "직급"
			, to_char(salary, '999,999,999')||'만원'  "연봉"
	from
		employee;
	-------------------------------------------------------
	to_char(salary, '999,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 `,` 를 삽입해서 문자로 리턴하기
	                                  만약 각 9 자리에 대응하는 숫자 없으면 화면에 출략이 안된다.
	-------------------------------------------------------
	to_char(salary, '099,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 `,` 를 삽입해서 문자로 리턴하기
																		맨앞에 0이 있으면 그자리가 비면 0이 대체된다. 따라서 나머지도 9이어도 다 0으로 대체가 된다.
	-------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<57> employee 테이블에서 수요일에 태어난 직원을 검색하라 (새로추가)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
to_char(
		to_date(
			case substr(jumin_num,7,1) when '1' then '19'
			when '2' then '19' else '20' end||substr(jumin_num,1,6)
			, 'YYYYMMDD'
		)
		, 'DY'
		, 'NLS_DATE_LANGUAGE = Korean'
	) = '수';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'DAY'
		,'NLS_DATE_LANGUAGE = Korean'
)
= '수요일';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'D'
		,'NLS_DATE_LANGUAGE = Korean'
)
= '4';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<58> employee 테이블에서 70년대생 남자 직원을 검색하라 (새로추가)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select * from employee
	where
		substr(jumin_num,1,1) = '7'
		and
		substr(jumin_num,7,1) = '1' ;
	--------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<59> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
	(substr(jumin_num,1,1) = '6'
	or
	substr(jumin_num,1,1) = '7'
	)
	and
	(substr(jumin_num,7,1) = '1'
	or
	substr(jumin_num,7,1) = '3'
	);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<60> employee 테이블에서 오래 근무한 직원이 먼저 나오게 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	order by
		(sysdate-hire_date)
	desc;
	---------------------------------------------
	sysdate-hire_date => 지금날짜 - 입사일. 날짜에서 날짜를 빼면 차이만큼 일수를 리턴한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<61> employee 테이블에서
 직원번호, 직원명, 근무일수, 근무개월수, 입사후 5개월후 날짜(년-월-일), 입사한달의마지막날짜(년-월-일), 입사한날짜에서돌아오는일요일날짜(년-월-일) 검색하면?
 단, 근무일수는 소수 2자리에서 반올림 하삼
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                                         "직원번호"
		,emp_name                                      "직원명"
		,round(sysdate-hire_date, 1)                   "근무일수"
		,months_between(sysdate,hire_date)             "근무개월수"
		,to_char(add_months(hire_date,5), 'YYYY-MM-DD')  "입사후5개월후날짜"
		,to_char(last_day(hire_date), 'YYYY-MM-DD')  "입사한달의마지막날짜"
		,to_char(next_day(hire_date,1), 'YYYY-MM-DD') "입사한날짜에서돌아오는일요일날짜"

 from
 	employee;
	*********************************************
	날짜함수 정리 (리턴값의 자료형을 조심하자)
	*********************************************
		---------------------------------------------
		months_between(날짜1, 날짜2) => 날짜1에 날짜2의 차이를 개월수로 리턴하기
		---------------------------------------------
	  add_months(날짜1, 개월수) => 날짜에 개월수 만큼 더한 날의 날짜를 리턴하기
		---------------------------------------------
		last_day(날짜) => 날짜가 속한 달의 마지막 날짜를 리턴하기
		---------------------------------------------
		next_day(날짜, 요일정수) => 날짜기준으로 돌아오는 요일의 날짜를 리턴하기
		                          요일정수는 1~7(1은일 ~ 토)
		---------------------------------------------
		날짜1 - 날짜2 => 날짜1 과 날짜2 의 차이를 일수로 리턴하기
		---------------------------------------------
		날짜 + 정수 => 날짜에다 정수만큼의 일수를 더한 만큼의 날의 날짜를 리턴하기
		---------------------------------------------
		날짜 - 정수 => 날짜에다 정수만큼의 일수를 뺀만큼의 날의 날짜를 리턴하기
		---------------------------------------------
	*********************************************

	round(숫자저장컬럼명, 반올림한 후 보여지는 소수자리수)
	=> round(sysdate-hire_date, 1) => 소수 둘째자리에서 반올림한 결과 리턴

	trunc(숫자저장컬럼명, 버린 후 보여지는 소수자리수)
	=> trunc(sysdate-hire_date, 1) => 소수 둘째자리 이후는 모두 버리고 리턴


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<62> employee 테이블에서 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<63> employee 테이블에서 직급이 과장이 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where jikup != '과장';
select * from employee where jikup <> '과장';

위의 두개는 같은 결과를 리턴하는것임.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<64> employee 테이블에서 부서번호가 10번이고 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where dep_no = 10 and jikup = '과장';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<65> employee 테이블에서 직급이 과장 또는 부장인 직원을 검색하면? (기)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where jikup = '과장' or jikup = '부장';
select * from employee where jikup in('과장', '부장');
select * from employee where jikup = any('과장', '부장');

in 은 `=` 없다.

any 왼쪽의 `=` 조심하자.

위의 세개는 같은 결과를 리턴하는것임.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<66> employee 테이블에서 10번, 20번 부서 중에 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where (dep_no = 10 or dep_no = 20) and jikup = '과장';
select * from employee where dep_no in(10, 20) and jikup = '과장';

in은 or가 먼저 연산되어서. `()` 안써도 된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<67> employee 테이블에서 담당직원이 없는 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from customer where emp_no is null;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<68> customer 테이블에서 담당직원이 있는 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from customer where emp_no is not null;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<69> customer 테이블에서 담당직원 번호가 9번이 아닌 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from customer where (emp_no != 9) or emp_no is null;
-------------------------------------------------
<주의> emp_no is null 조건도 붙이는 이유는 emp_no가 null 일 경우
emp_no != 9 조건에 포함되지 않기 때문이다.
즉, null 은 is null 또는 is not null 연산자에 의해서만 검색된다.



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<70> employee 테이블에서 연봉이 3000만원~4000 만원 사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where salary >= 3000 and salary <= 4000;
select * from employee where salary between 3000 and 4000;

<주의>
between 왼쪽에 컬럼명이 나온다.
select * from employee where between salary 3000 and 4000;  (X)
틀린것 조심하기.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<71> employee 테이블에서 연봉이 3000만원 이상 ~4000 만원 미만 사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where salary >= 3000 and salary < 4000;
select * from employee where (salary between 3000 and 4000) and salary != 4000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<72> employee 테이블에서 연봉을 5% 인상했다고 가정하고 3000 이상인 직원을  검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where salary*1.05 >= 3000


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<73> employee 테이블에서 입사일이 '1995-1-1' 이상인 직원을  검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where hire_date >= to_date('1995-1-1','YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<74> employee 테이블에서 입사일이 '1990년~1999년' 사이인 직원을  검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
	hire_date >= to_date('1990-1-1','YYYY-MM-DD')
	and
	hire_date < to_date('2000-1-1','YYYY-MM-DD');
-------------------------------------------------
select * from employee where
	to_number(to_char(hire_date, 'yyyy')) between 1990 and 1999;
-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<75> employee 테이블에서 부서번호가 10번 또는 30번인 직원 중에 연봉이 3000미만이고 입사일이 '1996-01-01' 미만 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where
(dep_no = 10 or dep_no = 30)  -- '()'를 해주어서 구분확실히..!
and salary < 3000
and hire_date < to_date('1996-01-01', 'YYYY-MM-DD');
-------------------------------------------------
select * from employee where
dep_no in(10,30)
and salary < 3000
and hire_date < to_date('1996-01-01', 'YYYY-MM-DD');
-------------------------------------------------
select * from employee where
dep_no =any(10,30)
and salary < 3000
and hire_date < to_date('1996-01-01', 'YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<76> employee 테이블에서 성이 김씨인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where substr(emp_name, 1,1) = '김';
	select * from employee where emp_name like '김%';
	-----------------------------------------------
	where 컬럼명 like '패턴문자열' => 컬럼명 안의 데이터가 패턴문자열을 갖고 있으면 그 행을 검색하라
	-----------------------------------------------
	emp_name like '김%';
	-----------------------------------------------
	=> 김이 첫글자고 두번째는 무엇이와도 좋고 길이에 제한없는 문자패턴을 골라라.
	=> 문자패턴 안의 %는 무엇이 와도 좋고 길이에 제한없음의 의미이다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<77> employee 테이블에서 성이 황씨인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--------------------------------------------------
select * from employee where
	substr(emp_name, 1,1) = '황'
	and
	substr(emp_name, 1,2) != '황보';
--------------------------------------------------
select * from employee where
	emp_name like '황%'
	and
	emp_name not like '황보%';
--------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<78> employee 테이블에서 이름이 2자인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where length(emp_name) = 2;
--------------------------------------------------
length(컬럼명) => 컬럼명 안의 문자데이터의 길이를 0이상의 정수로 리턴해주는 함수


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<79> employee 테이블에서 이름이 김으로 끝나는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name like '%김';
select * from employee where substr(emp_name, length(emp_name), 1) = '김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<80> employee 테이블에서 성이 김씨이고 3글자인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where substr(emp_name, 1, 1) = '김'
and length(emp_name) = 3;

select * from employee where emp_name like '김%'
and length(emp_name) = 3;

select * from employee where emp_name like '김__'
and length(emp_name) = 3;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<81> employee 테이블에서 이름에 김이란 문자를 가진 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name like '%김%';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<82> employee 테이블에서 성이 김씨가 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name not like '김%';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<83> employee 테이블에서 이름중간에만 김이 들어간 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name like '%김%'
and emp_name not like '김%'
and emp_name not like '%김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<84> employee 테이블에서 여자 직원을 검색하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
select * from employee where
substr(jumin_num,7,1) = '2' or substr(jumin_num,7,1) ='4';
-------------------------------------------------
select * from employee where
substr(jumin_num, 7, 1) in('2','4');
-------------------------------------------------
select * from employee where
jumin_num like '______2%' or jumin_num like '______4%'
-------------------------------------------------
select * from employee where
jumin_num not like '______1%' and jumin_num not like '______3%'
-------------------------------------------------
만약 주민번호 중간에 - 가 있다면 아래처럼 해도 된다.
-------------------------------------------------
select * from employee where
jumin_num like '-2%' or jumin_num like '-4%';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<85> employee 테이블에서 1960년대, 1970년대 출생자 중 남자만 검색하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select * from employee where
(substr(jumin_num,1,1) = '6' or substr(jumin_num,1,1) = '7')
and substr(jumin_num,7,1) = '1';
---------------------------------------------------------
select * from employee where
(substr(jumin_num,1,1) in ('6','7') and substr(jumin_num,7,1) = '1';
---------------------------------------------------------
select * from employee where
jumin_num like '6______1%' or jumin_num like '7______1%' ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<86> 기타 함수 정리하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------
숫자함수
-----------------------------------
	-------------
	abs(n)
	-------------
		▶ 숫자 n의 절대값을 반환
	-------------
	floor(n)
	-------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 왼쪽 정수값
			소수를 버려서 작아짐.
	-------------
	ceil(n)
	-------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 오른쪽 정수값
	-------------
	round(n,m)
	-------------
		▶ 숫자 n에서 소수 m+1 자리에서 반올림한 수 리턴
	-------------
	trunc(n,m)
	-------------
		▶ 숫자 n에서 소수 m+1 자리부터 버림
	-------------
	sign(n)
	-------------
		▶ n>0 이면 1, n<0 이면 -1, n=0 이면 0을 반환
	-------------
	mod(n,m)
	-------------
		▶ n/m 후 나머지 값을 반환
	-------------
	power(n,m)
	-------------
		▶ n의 m승을 반환


-----------------------------------
문자함수
-----------------------------------
	-------------
	chr(n)
	-------------
		▶ 정수 n을 ascii(아스키) 문자기호로 리턴한다

	-------------
	uppper(s)
	-------------
		▶ 문자열 s를 대문자로 변환시켜 리턴한다

	-------------
	lower(s)
	-------------
		▶ 문자열 s를 소문자로 변환시켜 리턴한다

	-------------
	length(s)
	-------------
		▶ 문자열 s의 길이를 리턴한다

	-------------
	substr(s, n1, n2)
	-------------
		▶ 문자열 s에서 n1번째 자리부터 n2개 까지의 문자를 리턴한다
		▶ n2 생략 시 마지막까지 문자를 리턴한다
		▶ n1이 0일 경우, 1로 바꿔 실행된다
		▶ 자리수는 n>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 셈한다
		-------------
		select substr( 'You are not alone', 9, 3 ) from dual;
		select substr( 'You are not alone', 5) from dual;
		-------------
		select substr( 'You are not alone', 0, 5 ) from dual;
		select substr( 'You are not alone', -5, 2 ) from dual;
		select substr( 'You are not alone', 5, 0 ) from dual;
	-------------
	trim(s)
	-------------
		▶ 문자열 s1의 맨 좌구측의 공백을 제거하여 리턴한다
			제거 후 또 있으면 계속 제거 후 리턴한다
	-------------
	replace( s1, s2, s3 ) ***
	-------------
		▶문자열 s1에서 s2를 s3로 수정해서 리턴한다.
		▶<예> select replace(addr, '서울특별시','서울시')  from employee
		-------------------------------
		select replace( 'You are not alone', 'You', 'We' ) from dual;
		select replace( 'You are not alone', 'not' ) from dual;
		select replace( 'You are not alone', 'not', '' ) from dual;
		-------------------------------
		select translate( 'You are not alone', 'You', 'We' ) from dual;
	-------------
	initcap( s )
	-------------
		▶문자열 s에서 각 단어의 첫 문자만 대문자로 변환하고 나머지는
		  모두 소문자로 리턴한다.
		▶select  initcap( 'abc def' ) from dual;
	-------------
	lpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 오른쪽 정렬 후 왼쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select lpad( 'abc', 7, ' ' ) from dual;
	-------------
	rpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 왼쪽 정렬 후 오른쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select rpad( 'abc', 7, '#' ) from dual;
	-------------
	instr( s1, s2, n1, n2 )  ***
	-------------
		▶( s1:타겟문자, s2:찾을문자, 에서 n1:검색시작위치, n2:몇번째에서 )
		<주의>오라클에서 위치를 따질 때 시작은 0이 아니라 1이다.
		▶문자열 s1 에서 문자열 s2 가 있는 위치 반환. (자바의 indexOf(~) 와 비슷한 기능)
		select
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la' ),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1, 2),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 12, 2)
		from dual;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> join(조인) 이 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	▶2개 이상의 테이블로부터 연관성있는 [컬럼]을 복사해서 횡으로 붙이는 작업을 말한다.
	▶예> 아래 직원번호와 직원명은 employee 테이블 소속이고, 소속부서명은 dept 테이블소속이다
	-----------------------------------
	직원번호      직원명     소속부서
	-----------------------------------
	   1          홍길동      총무부

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<88> join(조인) 의 종류?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	inner join
	-------------------------------------------------
		▶조인 조건에 맞는 행만 포함하는 조인. 대부분이 내부조인이다. (=내부조인 이라고도 한다)
	-------------------------------------------------
	outer join
	-------------------------------------------------
		▶조인 조건에 만족하지 못한 행도 출력하는 조인이다. 쪼까 어렵다. 시험문제 타겟..
	-------------------------------------------------
	self join
	-------------------------------------------------
		▶1개의 테이블을 2개 이상으로 보고 하는 조인이다. 쪼까 어렵다
	-------------------------------------------------
	cross join
	-------------------------------------------------
		▶2개 이상 테이블에서 각각의 행이 모두 연결되는 조인이다. 연결 조건이 생략된다.
		▶잘 사용되지 않는 조인이다.
	-------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<89> join(조인)에는 ANSI 조인형식과 오라클 조인이 있다는데 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	▶ANSI 조인
	-------------------------------------------------
		모든 DB 업체에서 공용으로 사용되는 조인이다.
	-------------------------------------------------
	▶오라클 조인
	-------------------------------------------------
		오라클에서만 사용되는 조인이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<90> 직원번호, 직원명, 소속부서명 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	▶<주의>직원번호와 직원명은 employee 테이블 소속이고, 소속부서명은 dept 테이블 테이블 소속이다.
	▶<주의>허걱! 이거 단순한 select 가 아닌 2개 테이블로 부터 연관성 있는 [컬럼]을 복사해서 횡으로 붙이는 작업. 즉, 조인이 필요하다.
	-------------------------------------------------
	<오라클 inner 조인>테이블에 별칭을 주지 않고 조인한 것.
	-------------------------------------------------
	select
		employee.emp_no
		,employee.emp_name
		,dept.dep_name
	from
		employee, dept
	where
		employee.dep_no=dept.dep_no
	-------------------------------------------------
	<오라클 inner 조인>별칭을 붙여서 조인하여 더 간략화.
	-------------------------------------------------
		select
			e.emp_no
			,e.emp_name
			,d.dep_name
		from
			employee e, dept d
		where
			e.dep_no=d.dep_no
	-------------------------------------------------
	<ANSI inner 조인>
	-------------------------------------------------
	select
		e.emp_no
		,e.emp_name
		,d.dep_name
	from
		employee e inner join dept d
	on
		e.dep_no=d.dep_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<91> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>담당직원이 있는 고객만 출력<inner join>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	<주의>담당직원이 있는 고객만 나와야하므로 즉, 조건에 맞는 행만 나와야하므로 inner 조인이다.
	-------------------------------------------------
	오라클 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<92> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>10번부서의 담당직원이 있는 고객만 출력<inner join>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	오라클 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no and e.dep_no = 10
	-------------------------------------------------
	<주의>오라클 조인에서 where 절에 조인 조건과 행을 골라내는 조건이 같이 나올수 있다. and 로 연결하면된다.
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	where
		e.dep_no = 10
	-------------------------------------------------
	<주의>ANSI 조인에서 on 절에 조인조건을 쓰고, where 절에 행을 골라내는 조건을 쓴다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<93> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>연봉이 3000만원 이상인 담당직원이 있는 고객만 포함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no and e.salary >= 3000;
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	where
		e.salary >= 3000;
	-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<94> [직원명], [직원직급], [직원부서명], [담당고객명], [고객전화]를 출력하면? <조건>직원 이름 오름차순 정렬
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	오라클 조인
	-------------------------------------------------
	select
		e.emp_name	"직원명"
		,e.jikup	"직원직급"
		,d.dep_name	"직원부서명"
		,c.cus_name	"담당고객명"
		,c.tel_num "고객전화번호"
	from
		 employee e, dept d, customer c
	where
		e.dep_no=d.dep_no and e.emp_no=c.emp_no
	order by
		e.emp_name asc;
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
		e.emp_name	"직원명"
		,e.jikup	"직원직급"
		,d.dep_name	"직원부서명"
		,c.cus_name	"담당고객명"
		,c.tel_num "고객전화번호"
	from
		 (employee e inner join dept d on e.dep_no=d.dep_no)
		 inner join customer c on c.emp_no=e.emp_no
	order by
		e.emp_name asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<95> 직원명, 직원직급, 소속부서명, 연봉등급 을 출력하면? 연봉등급 오름차순, 직급높은순서 오름차순, 나이높은 순서 내림 유지 요망
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
오라클 조인
-------------------------------------------------
select
	e.emp_name	"직원명"
	,e.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연봉등급"
from
	 employee e, dept d, salary_grade s
where
	e.dep_no=d.dep_no and (e.salary>=s.min_salary and e.salary<=s.max_salary)
--	e.dep_no=d.dep_no and (e.salary between s.min_salary and s.max_salary) between을 써도 된다.
order by
	s.sal_grade_no asc
	,decode(e.jikup, '사장',1 ,'부장',2, '과장',3, '대리',4,'주임',5,6) asc
	,	case
			when substr(e.jumin_num,7,1) in('1','2') then '19'
			else '20'
		end || substr(jumin_num,1,6)
		asc;
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
	e.emp_name	"직원명"
	,e.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연봉등급"
	from
		 (employee e inner join dept d on e.dep_no=d.dep_no)
		 inner join salary_grade s on (e.salary>=s.min_salary and e.salary<=s.max_salary)
	order by
		s.sal_grade_no asc
		,decode(e.jikup, '사장',1 ,'부장',2, '과장',3, '대리',4,'주임',5,6) asc
		,	case
			when substr(e.jumin_num,7,1) in('1','2') then '19'
			else '20'
		end || substr(jumin_num,1,6)
		asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<96> 부하직원명, 부하직원직급, 직속상관명, 직속상관직급을 출력하면? <조건>상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e1.emp_name	"직원명"
	,e1.jikup	"직원직급"
	,e2.emp_name	"직속상관명"
	,e2.jikup "직속상관직급"
from
	employee e1, employee e2
where
	e1.mgr_emp_no = e2.emp_no;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<97> 직속상관명, 직속상관직급, 부하직원명, 부하직원직급을 출력하면? <조건>상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
오라클 조인
-------------------------------------------------
내가한것.
select
	e2.emp_name	"직속상관명"
	,e2.jikup "직속상관직급"
	,e1.emp_name	"직원명"
	,e1.jikup	"직원직급"

from
	employee e1, employee e2
where
	e2.emp_no = e1.mgr_emp_no;
------------------------------------ 뭐가 다른지 비교해보기.
정답.
select
	e1.emp_name	"직속상관명"
	,e1.jikup	"직속상관직급"
	,e2.emp_name	"직원명"
	,e2.jikup "직원직급"
from
	employee e1, employee e2
where
	e1.emp_no = e2.mgr_emp_no ;
-------------------------------------------------
ANSI 조인
-------------------------------------------------
select
	e1.emp_name	"직속상관명"
	,e1.jikup	"직속상관직급"
	,e2.emp_name	"직원명"
	,e2.jikup "직원직급"
from
	employee e1 inner join employee e2
	on
	 e1.emp_no = e2.mgr_emp_no;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<98> 직원명, 직원직급, 소속부서명, 연봉등급, 직속상관명, 직속상관직급, 담당고객명 을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
오라클 조인
-------------------------------------------------
select
	e1.emp_name	"직원명"
	,e1.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연본등급"
	,e2.emp_name "직속상관명"
	,e2.jikup "직속상관직급"
	,c.cus_name "담당고객명"
from
	employee e1, dept d, salary_grade s, employee e2, customer c
where
	e1.dep_no = d.dep_no
	and (e1.salary between s.min_salary and s.max_salary)
	and e2.emp_no = e1.mgr_emp_no
	and e1.emp_no = c.emp_no;
-------------------------------------------------
ANSI 조인
-------------------------------------------------
select
	e1.emp_name	"직원명"
	,e1.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연본등급"
	,e2.emp_name "직속상관명"
	,e2.jikup "직속상관직급"
	,c.cus_name "담당고객명"
from
	(((employee e1 inner join dept d on e1.dep_no = d.dep_no)
	inner join salary_grade s on e1.salary between s.min_salary and s.max_salary)
	inner join employee e2 on e2.emp_no = e1.mgr_emp_no)
	inner join customer c on e1.emp_no = c.emp_no;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<99> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>담당직원이 없는 고객도 포함(고객은 다나와야함)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------------
	<주의>담당직원이 없는 고객도 포함 하라는 얘기는 고객은 다 나오라는 말이다. 즉, outer 조인하라는 말이다.
		outer 조인은 한쪽은 다 나오라는 조인이다. 나머지는 조건에 안맞더라도 null 달고라도 나오라는 조인
	----------------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_no "부서번호"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+);
	----------------------------------------------------------
	▶c.emp_no=e.emp_no(+) 의미
		(+)가 붙은 컬럼의 반대편 컬럼의 소속 테이블 행은 모두 나오고
		(+)가 붙은 e.emp_no 컬럼의 소속테이블 행은 조건에 맞는게 없으면 null 이라도 달고 나오라는 뜻
		c.emp_no = e.emp_no(+)
	----------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<100> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면?
<조건> 고객정보는 모두 보이고 직원정보는 10번 부서만 보일것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	********************************************************
	오라클 조인
	********************************************************
	select
		c.cus_no "고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_no "부서번호"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+)
		and e.dep_no(+) = 10;
	********************************************************
	---------------------------------------------------------
	<주의> outer join 에서 where 에 (+)가 붙는 놈은?
	---------------------------------------------------------
		where 절에 다나오는 메인 테이블 소속이 아닌 모든 컬럼에 붙는다.
		심지어 행을 골라내는 조건의 컬럼도 여기에 속한다.
	---------------------------------------------------------
	<세끼문제>만약 e.dep_no(+)=10 을 e.dep_no=10 로 수정하면?
	---------------------------------------------------------
		▶담당직원이 10번 부서인 고객만 포함된다.
		마치 inner join 결과 처럼 보인다.
	********************************************************
	ANSI 조인
	********************************************************
	select
		c.cus_no "고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_no "부서번호"
	from
		customer c left outer join employee e
	on
		c.emp_no = e.emp_no and	e.dep_no = 10;
	********************************************************
	---------------------------------------------------------
	<주의> ANSI조인에서 left outer join 나오면 left outer join 왼쪽에 있는 테이블이 다나오는 테이블이다.
	---------------------------------------------------------
	<주의> ANSI조인에서 right outer join 나오면 right outer join 오른쪽에 있는 테이블이 다나오는 테이블이다.
	---------------------------------------------------------
	<세끼문제>만약 e.dep_no(+)=10 를 따로 빼내서 where e.dep_no =10 로 추가하면?
	---------------------------------------------------------
		▶where 절이 있으면 행을 골라내므로 고객이 2명만 나온다.
		▶ANSI 방식의 outer join에서는 행을 골라내는 조건도 on 절에 들어가야한다.
		만약에 where 절을 쓰면 메인테이블이 다 나오지 않을수 있다.
-

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<101> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 담당직원연봉등급을 출력하면?
<조건> 담당직원이 없는 고객도 포함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		c.cus_no "고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,s.sal_grade_no "담당직원 연봉등급"
	from
		customer c, employee e, salary_grade s
	where
		c.emp_no = e.emp_no(+)
		--and e.salary between s.min_salary(+) and s.max_salary(+)
	    and
			s.min_salary(+) <= e.salary and s.max_salary(+) >= e.salary
	order by
		c.cus_no asc;
	---------------------------------------------------------
	<주의> employee 입장에서는 메인 테이블은 customer 이고, salary_grade 테이블 입장에서는 메인테이블은 employee 이다. 메인에 딸려나오는 테이블의 컬럼에 (+)를 붙이면 된다.
	---------------------------------------------------------
	<주의>아래 처럼은 안된다. 즉, (+)를 양쪽에 붙일수는 없다.
	s.min_salary(+) <= e.salary(+) and s.max_salary(+) >= e.salary(+)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<102> 고객번호, 고객명, 고객주민번호 출력하라. 단, 연봉이 3000 이상인 담당직원이 담당한 고객이어야 한다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,c.tel_num	"고객전화번호"

from
	customer c, employee e
where
	e.salary>=3000 and e.emp_no=c.emp_no


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<103> 고객번호, 고객명, 고객주민번호 출력하라. 단 40살 이상인 담당직원이 담당한 고객이어야한다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
내가한것.
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,c.jumin_num	"고객주민번호"

from
	customer c, employee e
where
	to_number(to_char(sysdate, 'YYYY'))
	- to_number(
		case substr(e.jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
		||substr(e.jumin_num,1,2)+1) >= 40 and e.emp_no=c.emp_no;
--------------------------------------------------------
정답.
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,c.jumin_num	"고객주민번호"

from
	customer c, employee e
where
	c.emp_no = e.emp_no
	and
		(
			extract(year from sysdate)
			-
			extract(
					year from
					to_date(
						decode(substr(e.jumin_num,7,1), '1', '19', '2', '19', '20')
							||substr(e.jumin_num,1,6)
						,'YYYYMMDD'
					)
			)+1
		)>=40
--------------------------------------------------------
<주의>코딩 상 분명히 조인이지만 출력되는 컬럼은 한개의 테이블에서 나오는 컬럼이다. 위 코딩은 조인이 출력 목적이 아닌, 조건목적으로 사용된것이다.
--------------------------------------------------------
<추가문제>10부서 또는 30번 부서 직원이 담당하는 고객을 검색하면?
--------------------------------------------------------



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<104> 고객번호, 고객명, 담당직원번호, 담당직원명, 담당직원소속부서명, 담당직원연봉등급, 담당직원직속상관명, 담당직원직속상관직급, 직속상관연봉등급 출력하라. 단, 고객은 다 나와야하고 null은 없음 으로 표시.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,nvl(to_char(e1.emp_no),'없음')	"담당직원번호"
	,nvl(e1.emp_name,'없음') "담당직원명"
	,nvl(d.dep_name,'없음') "담당직원소속부서명"
	,nvl(to_char(s1.sal_grade_no),'없음') "담당직원연봉등급"
	,nvl(e2.emp_name,'없음') "담당직원직속상관명"
	,nvl(e2.jikup,'없음') "담당직원직속상관직급"
	,nvl(to_char(s2.sal_grade_no),'없음') "직속상관연봉등급"
	--,nvl(c.cus_name||'','없음')
from
	customer c, employee e1, dept d, salary_grade s1, employee e2, salary_grade s2
where
	c.emp_no = e1.emp_no(+)
	and
	e1.dep_no = d.dep_no(+)
	and
	e1.mgr_emp_no = e2.emp_no(+)
	and
	--s1.min_salary(+) <= e1.salary and s1.max_salary(+) >= e1.salary
	e1.salary between s1.min_salary(+) and s1.max_salary(+)
	and
	--s2.min_salary(+) <= e2.salary and s2.max_salary(+) >= e2.salary
	e2.salary between s2.min_salary(+) and s2.max_salary(+)
order by
c.cus_no asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<105> 직원명, 직원전화번호와 고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복하지 말것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------
union
----------------------------------------
	서로 다른 테이블의 컬럼을 종으로 붙이는 작업을 말한다.
	union 규칙
		=> 컬럼의 개수가 일치해야 한다.
		=> 붙는 컬럼의 자료형이 일치해야 한다.
----------------------------------------
select emp_name||'직원', phone from employee
union
select cus_name||'고객', tel_num from customer
----------------------------------------
union 만 쓰면 중복행을 제거한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<106> 직원명, 직원전화번호와 고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복허락
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------
select emp_name, phone from employee
union all
select cus_name, tel_num from customer
----------------------------------------
union all 을 쓰면 중복행을 허락한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<107> subquery(서브쿼리)가 뭐죠?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------------------------------
	select, insert, update, delete 구문 안에 들어 있는 또 다른 select 문을 말한다.
	------------------------------------------------------------------------------
	<주의>from 절에 나오는 select는 서브쿼리가 아니라 inline(인라인뷰)라고 부른다.
	------------------------------------------------------------------------------
	----------------------------
	서브쿼리 사용 시 주의점
	----------------------------
		select, update, delete 안의 서브커리는 꼭 ( )로 묶는다.
		경우에 따라 조인대신 서브쿼리를 써도 같은 결과를 낼 수 있다. 이때 join 보다 서브쿼리의 부하가 더 많이 걸린다.
		현업가면 개성마다 다르다.
	----------------------------
	서브쿼리 종류
	----------------------------
		비상관쿼리(Noncorrelated Subquery)
		----------
			[서브쿼리]와 [외부쿼리]가 연관성이 없다.
			[서브쿼리] 실행 후의 결과값을 가지고 [외부쿼리] 실행된다.

			<예> 평균 연봉 이상 받는 직원을 검색하면?
			select * from employee where salary >= (select avg(salary) from employee)
		----------
		상관쿼리(Correlated Subquery)
		----------
			[서브쿼리]와 [외부쿼리]가 연관성이 있다.
			[서브쿼리]와 [외부쿼리]가 서로 통신하면서 쿼리가 진행된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<108> 최고 연봉을 받는 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where salary = (select max(salary) from employee);
	---------------------------------------------------
	서브쿼리 select max(salary) from employee 가 먼저 실행되고 난 후 리턴되는 최고연봉을 가지고 바깥 쿼리가 실행 된다.
	위 쿼리는 비상관 쿼리이다.[서브쿼리] 실행 후의 결과값을 가지고 [외부쿼리] 실행되기 때문이다.
	<주의> ~ where salary = max(salary); -> 이렇게 하면 안된다.



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<109> 평균 연봉 이상을 받는 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where salary >= (select avg(salary) from employee)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<110> 20번 부서에서 최고 연봉자 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------------------------
	select * from employee
	where salary = (select max(salary) from employee where dep_no = 20) and dep_no = 20;
	----------------------------------------------------------------------
	아래처럼 하면 문제가 바뀐다.
	"20번 부서의 최고연봉자와 동일한 연봉을 받는 모든 직원을 검색하라" 이렇게 바뀐다.
	----------------------------------------------------------------------
	select * from employee
	where salary = (select max(salary) from employee where dep_no = 20)

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<111> [직원명], [직급], [연봉], [전체연봉에서 차지하는 비율]을 검색하라. [전체연봉에서 차지하는 비율]은 소수점 버림하고 %로 표현하다.
단, 높은 비율이 먼저 나오게 정렬하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------------------------
	select
			emp_name "직원명"
			,jikup "직급"
			,salary "연봉"
			,floor(salary / (select sum(salary) from employee) * 100) ||'%' "연봉비율"
	from
			employee
	order by
			salary/(select sum(salary) from employee)*100 desc;
	-------------------------------------------------------------------
	select
			emp_name "직원명"
			,jikup "직급"
			,salary "연봉"
			,trunc(salary / (select sum(salary) from employee) * 100, 1) ||'%' "연봉비율"   -- trunc 사용하여 소수점 조절.
	from
			employee
	order by
			salary/(select sum(salary) from employee)*100 desc;
	-------------------------------------------------------------------
	<주의>정렬할때는 소수점 컨트롤을 하지 말고 소수점이 널부러지게 하고 정렬해야 정확한 정렬이 된다.
	-------------------------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<112> 10번 부서 직원들이 관리하는 [고객번호], [고객명], [직원번호]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------------------------
<1>조인(join) 답
-------------------------------------------------------------------
select
	c.cus_no
	,c.cus_name
	,c.emp_no
from
	customer c, employee e
where
	c.emp_no = e.emp_no and e.dep_no = 10;
-------------------------------------------------------------------
<2>서브쿼리(subquery) 중 비상관쿼리 답1
-------------------------------------------------------------------
select
	cus_no "고객번호"
	,cus_name "고객명"
	,emp_no
from
	customer
where
	emp_no in(select emp_no from employee where dep_no=10)
-------------------------------------------------------------------
n행1열 서브쿼리 쓰면 , 자동으로 붙어서 나오게 된다.
-------------------------------------------------------------------
	in 뒤에 n행 1열의 결과가 나오는 서브쿼리가 나오면 n행 1열의 데이터가 in 뒤에 콤마(,)로 나열된다.
-------------------------------------------------------------------
<3>서브쿼리(subquery) 중 비상관쿼리 답2
-------------------------------------------------------------------
	select
		cus_no "고객번호"
		,cus_name "고객명"
		,emp_no
	from
		customer
	where
		emp_no = any(select emp_no from employee where dep_no=10)
-------------------------------------------------------------------
<4>서브쿼리(subquery) 중 상관 쿼리 답1
-------------------------------------------------------------------
select
	c.cus_no
	,c.cus_name
	,c.emp_no
from
	customer c
where
	(select e.dep_no from employee e where c.emp_no=e.emp_no) = 10;
-------------------------------------------------------------------
<5>서브쿼리(subquery) 중 상관 쿼리 답2
-------------------------------------------------------------------
select
	c.cus_no
	,c.cus_name
	,c.emp_no
from
	customer c
where
	(select count(*) from employee e where c.emp_no = e.emp_no and e.dep_no=10)>0;



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<113> 평균 연봉 이상이고 최대 연봉 미만의 [직원명], [연봉], [전체평균연봉], [전체최대연봉]을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	emp_name "직원명"
	,salary "연봉"
	, (select avg(salary)from employee)  "전체평균연봉"
	, (select max(salary)from employee)  "전체최대연봉"
from
	employee
where
	salary>= (select avg(salary) from employee)
	and
	salary< (select max(salary) from employee);

-

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<114> 최고연봉 직원의 [직원번호], [직원명], [부서명], [연봉]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e.emp_no
	,e.emp_name
	,d.dep_name
	,e.salary

from
 dept d, employee e

where
d.dep_no = e.dep_no
and
e.salary = (select max(salary) from employee);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<115> 담당 고객이 2명 이상인 [직원번호], [직원명], [직급]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e.emp_no
	,e.emp_name
	,e.jikup
from
	employee e
where
	(select count(*) from customer c where e.emp_no=c.emp_no) >=2;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<116> [직원번호], [직원명], [소속부서명]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------------------------------------
조인(join) 답
-----------------------------------------------------------------
select
	e.emp_no    "직원번호"
	,e.emp_name "직원명"
	,d.dep_name "소속부서명"
from
	employee e, dept d
where
	e.dep_no = d.dep_no;
-----------------------------------------------------------------
서브쿼리 답
-----------------------------------------------------------------
select
	e.emp_no    "직원번호"
	,e.emp_name "직원명"
	,(select d.dep_name from dept d where d.dep_no = e.dep_no) "소속부서명"
from
	employee e;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<117> [직원번호], [직원명], [연봉], [연봉순위]를 출력하면? 단 [연봉순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e1.emp_no    "직원번호"
	,e1.emp_name "직원명"
	,e1.salary   "연봉"
	,(select count(*)+1 from employee e2 where e2.salary>e1.salary)  "연봉순위"
from
 employee e1
order by
	4 asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<118> [직원번호], [직원명], [담당고객수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e.emp_no    "직원번호"
	,e.emp_name "직원명"
	,(select count(*) from customer c where c.emp_no = e.emp_no) "담당고객수"
from
	employee e;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<119> 애래 처럼 [부서명], [부서직원수], [부서담당고객수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	d.dep_name "부서명"
	,(select count(*) from employee e where e.dep_no = d.dep_no)||'명'  "부서직원수"
	,(select count(*) from employee e, customer c where e.dep_no = d.dep_no and e.emp_no = c.emp_no)||'명' "부서담당고객수"
from
	dept d
order by 2 desc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<120> [직원번호], [직원명], [직급], [주민번호], [직급서열순위]를 출력하면? *****
단, 직급이 같으면 나이 많은 직원이 [직급서열순위] 위이다. 그리고 [직급서열순위]를 오름차순 유지.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e1.emp_no
	,e1.emp_name
	,e1.jikup
	,e1.jumin_num
	,(select count(*)+1 from employee e2 where decode( e2.jikup
		,'사장', 1
		,'부장', 2
		,'과장', 3
		,'대리', 4
		,'주임', 5
		,6
	)|| decode (substr(e2.jumin_num,7,1), '1', '19', '2', '19', '20' )
    || substr(e2.jumin_num,1,6)
	< decode( e1.jikup
		,'사장', 1
		,'부장', 2
		,'과장', 3
		,'대리', 4
		,'주임', 5
		,6
	)|| decode (substr(e1.jumin_num,7,1), '1', '19', '2', '19', '20' )
    || substr(e1.jumin_num,1,6) )
	 "직급서열순위"
from
	employee e1
order by
	5 asc;

-----
select
	e1.emp_no      "직원번호"
	,e1.emp_name   "직원명"
	,e1.jikup      "직급"
	,e1.jumin_num  "주민번호"
	, (select count(*)+1 from employee e2 where case (e2.jikup
		when '사장' then 1
		when '부장' then 2
		when '과장' then 3
		when '대리' then 4
		when '주임' then 5 else 6
	end
	)|| case (substr(e2.jumin_num,7,1)
	 	when '1' then '19'
		when '2' then '19'
		else '20' end)
		|| substr(e2.jumin_num,1,6)
< case (e1.jikup
	when '사장' then 1
	when '부장' then 2
	when '과장' then 3
	when '대리' then 4
	when '주임' then 5 else 6
end
)|| case (substr(e1.jumin_num,7,1)
	when '1' then '19'
	when '2' then '19'
	else '20' end)
	|| substr(e1.jumin_num,1,6)
) "직급서열순위"
from
	employee e1
order by 5;
---
select
	e1.emp_no      "직원번호"
	,e1.emp_name   "직원명"
	,e1.jikup      "직급"
	,e1.jumin_num  "주민번호"
	,(
		select count(*)+1 from employee e2
		where
		decode( e2.jikup
			,'사장', 1
			,'부장', 2
			,'과장', 3
			,'대리', 4
			,'주임', 5
			,6)
		<
		decode( e1.jikup
			,'사장', 1
			,'부장', 2
			,'과장', 3
			,'대리', 4
			,'주임', 5
			,6)
		or
		(
			e2.jikup = e1.jikup
			and
			decode (substr(e2.jumin_num,7,1), '1', '19', '2', '19', '20' )
		    ||substr(e2.jumin_num,1,6)
			<
			decode (substr(e1.jumin_num,7,1), '1', '19', '2', '19', '20' )
		    ||substr(e1.jumin_num,1,6)
		)
	)
from
	employee e1
order by
	5;
-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<121> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 부서번호 를 출력하면? <조건>담당직원이 없는 고객도 포함
단, 조인을 사용하지 말고 서브쿼리를 사용하십시오.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	서브쿼리 답
	---------------------------------------------
	select
	  c.cus_no     "고객번호"
	  ,c.cus_name  "고객명"
	  ,c.tel_num   "고객전화번호"
	  ,(select e.emp_name from employee e where e.emp_no = c.emp_no ) "담당직원명"
	  ,(select e.jikup from employee e where e.emp_no = c.emp_no ) "담당직원직급"
	  ,(select e.dep_no from employee e where e.emp_no = c.emp_no )"부서번호"
	from customer c;
	---------------------------------------------
	조인 답(오라클조인)
	---------------------------------------------
	select
	  c.cus_no     "고객번호"
	  ,c.cus_name  "고객명"
	  ,c.tel_num   "고객전화번호"
	  ,e.emp_name  "담당직원명"
	  ,e.jikup     "담당직원직급"
	  ,e.dep_no    "부서번호"
	from
	  customer c, employee e
	where
	  c.emp_no = e.emp_no(+)
	order by
	1 asc;
	---------------------------------------------
	조인 답(ANSI 조인)
	---------------------------------------------
	select
	  c.cus_no     "고객번호"
	  ,c.cus_name  "고객명"
	  ,c.tel_num   "고객전화번호"
	  ,e.emp_name  "담당직원명"
	  ,e.jikup     "담당직원직급"
	  ,e.dep_no    "부서번호"
	from
	  customer c left outer join employee e
	on
	  c.emp_no = e.emp_no
	order by
	1 asc;

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<122>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
















■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<> 직급별, 평균 연봉 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	jikup
	,avg(salary)
from
employee
group by
	jikup;


			select * from employee where emp_name like '%김%'
			select * from employee where instr(emp_name, '김')>0;
			------------------------------------------------------------
			select * from employee where instr(emp_name, '김')=1;
			select * from employee where emp_name like '김%'
=======================================================
