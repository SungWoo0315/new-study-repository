■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<1> 데이터베이스?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류하여 정리해 놓은 [자료의 집합]을 말한다.
데이터베이스 조건( 입.기 )  // 입: 입사시험문제. // 기 : 정보처리 기사 시험문제.
	실시간 접근성, 지속적인 변화(=최신의 정보가 정확하게 저장), 동시 공유 등

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<2> RDBMS (Relational Database Management System, 관계형 데이터베이스 관리 시스템) 란?	(입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●데이터가 [컬럼(column=열)]과 [로우(Row=행)]로 이루어진 [테이블]에 저장되며, [테이블]들 사이에 관계를 설정하여
 관리하는 SW 또는 시스템을 말한다.

●RDBMS 제품의 종류
	Oracle 사의 Oracle		=> 대기업용. 현재 대기업 공기업 프로젝트에 제일 많이 사용하고 있음.
	MS 사의 MS-SQL		=> 대기업용
	Sun Microsystems 사의 MYSQL => 중소기업용
	Sybase
	DB2 등
●고객의 정보를 저장하는 테이블 custumer가 있다면 아래와 같은 구조로 데이터를 저장하여 관리한다.
면 아래와 같은 구조로 데이터를 관리한다.
---------------------------------------------------------------------

		custumer                             => 테이블명
------------------------------------------
고객번호       고객명      주소       전화번호         =>column 명
------------------------------------------
1              저팔계      서울      02-1234-1234       =>row(행)
------------------------------------------
2              사오정      부산      02-2345-2345       =>row(행)
------------------------------------------
3              손오공      제주      02-3456-3456       =>row(행)
------------------------------------------
↓              ↓          ↓            ↓
column      column      column      column
(컬럼)       (컬럼)       (컬럼)        (컬럼)
(열)          (열)         (열)          (열)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<3> SQL(Structured Query Language) 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS에 접근해서 데이터의 [입력], [수정], [삭제], [검색] 하는 등의 기능을 가진 RDBMS 관리 언어 이다.
  <참고> DB, 즉 오라클을 배운다라는 말은 SQL 언어를 배우는 것과 동일하다.
●특징
	▶[절차적 언어]가 아닌 [구조적 언어]이다.  //솔루션 회사에서 물어볼 수 있음.
	   <참고>절차적(procedural) 언어 (입)
		▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. (C, Java 등)
	   <참고>구조적(structured) 언어 (입)
		▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만
                      	   나열하만 로직이 처리되는 언어. (SQL...)

	// Oracle ex) 구조적 언어
	select count(*) from employee


●SQL 종류 ( 기, 입)
	--------------------------------
	DDL(Data Definition Language = 데이터 정의 언어)
	--------------------------------
		▶객체를 생성, 수정, 삭제 등의 작업을 한다.
		----------------------
		CREATE => 객체 생성
		ALTER => 객체 수정. <조심>update가 아니다. 시험문제에 자주 등장.
		DROP => 객체 삭제
		기타 등등
		----------------------
		<주의>오라클에서 객체란 이름을 가지고 저장되는 놈들을 객체라 부른다. 자바의 객체와 다르다.
		<참고>오라클에서 객체는 [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등 을 말한다.

	--------------------------------
	DML(Data Manipulation Language = 데이터 처리 언어)
	--------------------------------
		▶테이블 안의 데이터를 입력, 수정, 삭제, 검색 등의 작업을 한다.
		--------------------------------
		INSERT => [행단위]의 데이터 입력
		UPDATE => [셀 단위]의 데이터 수정/삭제
		DELETE => 행 단위의 데이터 삭제
		SELECT => n행 m열의 데이터 검색 SQL 공부의 90%차지한다. DB 실력은 SELECT 구사 능력이다.
		기타 등등
		--------------------------------
		<문> 셀에 들어있는 데이터를 제거하는 SQL구문은?  => UPDATE !!!	학원 프로젝트에 주도적으로 참여 했는지 알 수 있는 질문.
		<문> 행을 제거하는 SQL구문은?  => DELETE !!!

	--------------------------------
	DCL(Data Control Language = 데이터 제어 언어)
	--------------------------------
		COMMIT		=> 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정
		ROLLBACK	=> 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소
		GRANT		=> 접근제어, 작업권한허용
		REVOKE		=> 권한제거



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<4>트랜잭션(Transaction) 이란 뭡니까? (입.기.실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위를 말한다.	//포괄적
●트랜잭션은 주로 입력 또는 수정 또는 삭제 SQL 구문 실행 시 설정한다.		//실무적
●트랜잭션이 걸린 작업은 가상 작업이 되고 rollback 를 실행하면 모두 취소되고 commit 를 실행하면
  가상작업이 모두 실제로 작업으로 인정된다.
●<주의>트랜잭션은 의도를 가지고 설정하는 것이다.
●<주의>트랜잭션이 없는 작업은 N가지 이상의 다양한 결과로 진행 될 수 있다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<5>오라클에서 [계정] 이란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●오라클에 접속하는 사용자를 말한다.
●사용자 마다 권한을 다르게 줄 수 있다.
●오라클은 다수의 클라이언트에게 동시에 정보를 제공하는 서버이므로 서버의 특징인 계정과 암호를 가지고 있다.
--------------------------------
<참고>서버(SERVER)?
--------------------------------
	다수의 클라이언트에게 동시에 정보를 제공하는 H/W 나 S/W 를 말한다.

●오라클 계정의 종류
	-------------------------------------------------------------------
	SYS		-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다. 반지의 제왕!
	-------------------------------------------------------------------
	SYSTEM		-> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다.
			단 [데이터베이스] 생성 권한이 없다.
	-------------------------------------------------------------------
	SCOTT		-> 오라클 설치 시 기본적으로 만들어지는 계정. 권한이 거의 없다.
	-------------------------------------------------------------------
	생성 계정		-> 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정된다.
			주로 SYS, SYSTEM 계정 또는 SYS, SYSTEM 계정과 동일한 권한을 가진 계정이 만든다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<6>데이터베이스 차원에서 스키마 (Schema) 란 뭡니까? (입, 기, 실) 대형 솔루션 회사 입사 시험 타겟!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[데이터베이스의 구조]에 대한 정의와 제약조건 등을 기술한 [명세서]를 말한다.	// 데이터 베이스 한정 정의.
●[계정]이 생성한 모든 [객체]들을 의미 한다. (오라클 객체=>테이블, 뷰, 인덱스, 프로시저, 트리거 등)
  객체들이 DB 구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.
●[kim] 계정이 객체(테이블,인덱스,뷰 등)들을 생성했다면 이 객체들 모두를 가리켜 [kim 스키마]라고 한다.
●생성되는 객체는 [계정명.객체명] 형식으로 저장된다.

<예>abc 계정으로 로그인해 => employee 테이블 생성.  abc.employee 형태로 저장됨.
<예>kim 계정으로 로그인해 => employee 테이블 생성.  kim.employee 형태로 저장됨.
<예>kim 계정으로 로그인해 => employee 테이블 생성.  kim.employee 형태로 저장 안됨. 이미 있으니까.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<7>데이터베이스 차원에서 테이블(table) 란 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS 에서 데이터가 실질적으로 저장되는 [논리적 장소(=S/W 적인 장소)]를 말한다.
●[컬럼(column=열)]과 [로우(Row=행=record)]로 구성되어 있다.
●테이블은 이름가지고 저장되는 객체의 한 종류이다.
●개발자 입장에서 제일 손이 많이 가는 객체이다.
●테이블에 데이터를 입력하는 SQL 이 insert 이다.
●테이블에 데이터를 수정하는 SQL 이 update 이다.
●테이블에 데이터를 삭제하는 SQL 이 delete 이다.
●테이블에 데이터를 검색하는 SQL 이 select 이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<8>테이블(table) 을 생성하는 SQL 구문의 형식은?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

-------------------------------------
CREATE TABLE 테이블명(
		컬럼명1		자료형		제약조건
		, 컬럼명2		자료형		제약조건
		, ~
		, 컬럼명n		자료형		제약조건
);
-------------------------------------
CREATE TABLE 테이블명(
		컬럼명1		자료형		제약조건,
		컬럼명2		자료형		제약조건,
		 ~         ~           ~	,
		컬럼명n		자료형		제약조건
);
-------------------------------------
	-------------------------------------
	자료형(Data type) => 테이블의 컬럼에 입력될 데이터의 유형을 말한다. 문자형, 숫자형, 날짜형 등이 있다.
	-------------------------------------
	제약조건 => 입력되는 데이터의 입력 가능 조건을 말한다. 제약조건에 위배되는 데이터는 삽입될 수 없다
			제약조건이 생략되면 데이터가 입력되지 않을 경우 null 이 저장된다.
	-------------------------------------
	<주의>테이블명, 컬럼명 제작 규칙
			▷영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다.
			▷30자를 초과할 수 없다. SQL 예약어는 사용할 수 없다.
			▷하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야한다.
			▷테이블명, 컬럼명, 제약조건명을 " 로 감싸거나 " 없이 그냥 써도된다.
			▷▷테이블명, 컬럼명 은 가독성 있게 주는 것이 제일 중요하다.

	자바에서 " 와 ' 가 언제 사용되는지 설명?
	String 형 ""
	char 형 ''

	String str1 = "산";
	String str2 = '산';	// '' 때문에 에러/ 변수선언이 먼저이기 때문에 String 이기때문에 ""로 바꿔주어야 맞다.
	char str3 = '산너머';  // char 형이라서 길이가 세글자라서 에러.
	String str4 = '산너머'; // "" 로 안써서 에러
	// 셋다 들어간 데이터가 잘못된것이다.

	오라클에서 " 와 ' 가 언제 사용되는지 설명?

	자바스크립트에서 " 와 ' 가 언제 사용되는지 설명?


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<9> 오라클에서 자료형의 종류는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
오라클은 대문자가 원칙이지만 소문자도 상관은 없음.

-------------------
CHAR(s)
-------------------
	▶고정길이 문자열 저장. s는 byte수를 의미.
	▶설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
	▶설정 크기보다 입력 문자 크기가 크면 ? 행 자체가 입력되지 않는다.
	▶<예>CHAR(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
			<참고>영문 1자는 1byte 차지, 한글 1자는 2byte차지.
	▶최대크기는 2000Byte 이다.
	▶CHAR 는 CHAR(1) 과 동일. ex) 성별 표현. m/w 두가지만. 표현하기 때문.

-------------------
VARCHAR2(s)
-------------------
	▶가변길이 문자열 저장. s 는 byte 수를 의미.
	▶설정 크기보다 입력문자 크기가 작으면 크기가 자동으로 줄어든다. (DB 서버 부담은 증가)
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<예>VARCHAR2(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능.
	▶보통 테이블을 설계할 때는 CHAR 타입보다는 VARCHAR2 타입을 많이 사용한다.
		임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문이다.
	▶최대크기는 4000Byte 이다.
	▶VARCHAR2 만 쓸수는 없다. // CHAR랑 혼동하지 말것!!

-------------------
NUMBER(p,s)
-------------------
	▶정수형 또는 실수형 숫자 저장.
	▶p(precision) => 전체 자릿수(1~38). s(scale) => 소수점이하 자릿수(-84~127)
	▶s 생략 시 디폴트 0 설정.
	▶NUMBER 는 즉 p(precision), s(scale) 모두 생략 시 정수, 소수점이하 자릿수 합쳐 40자리 까지 저장.
	▶소수점 자리수가 넘치면 반올림하고 정수 자리수가 넘치면 오류가 난다. 즉, 행 입력이 안된다.
	--------------------------------------------------
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.56 저장하면? 1234.56 저장.
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 1234.567 저장하면? 1234.57 저장. 반올림 한 후 소수점 2자리 까지 저장.
	▶<예> NUMBER(6, 2) 라고 지정한 컬럼에 12345.6 저장하면? 저장오류(행 자체가 못들어감). 정수 자릿수 부족으로 오류
	--------------------------------------------------
	▶<예> NUMBER(3) 라고 지정한 컬럼에 123 지정하면? 123 저장
	▶<예> NUMBER(3) 라고 지정한 컬럼에 123.4 지정하면? 123 저장. 소수점 1자리에서 반올림해서 저장.
	▶<예> NUMBER(3) 라고 지정한 컬럼에 1234 지정하면? 저장오류. 정수부문 자릿수 부족으로 오류.


-------------------
DATE
-------------------
	▶[년, 월, 일, 시, 분, 초] 저장.
	▶저장 범위는 BC 4712년 1월 1일~9999년 12월 31일.
	▶<참고>보통 날짜형 데이터는 SQL 문장에서 [TO_CHAR] 변환함수, [TO_DATE] 변환함수와 같이 사용된다.

	▶<참고>2021년06월11일 부터 ▶2021년12월25일 까지 남은 일수 검색하는 SQL 구문 작성?
		---------------------------------------------------
		select to_date('2021225', 'YYYYMMDD')-to_date('20210611', 'YYYYMMDD') from dual
		---------------------------------------------------
	▶<참고>오늘 날짜를 예쁘게 연-월-일 로 검색하는 SQL 구문작성?
		---------------------------------------------------
		select to_char(sysdate. 'YYYY-MM-DD') from dual
		---------------------------------------------------
	▶<참고>변환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER] 와 같이 사용된다.

------------------
<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE 도 있다.
<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.
------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<10> 오라클에서 제약조건의 종류는? (입, 기, 실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

----------------
not null
----------------
	▶반드시 데이터가 입력돼야 한다. 비지마! 필수입력 데이터 니까!

----------------
unique
----------------
	▶중복되는 데이터는 입력 불가능하다. 중복마!
	▶<예>주민번호, 전화번호, 직원번호 등등
	▶일반적으로 또는 관용적으로, 실무적으로 unique 을 가진 컬럼은 not null 도 같이 들어간다.

----------------
default
----------------
	▶데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
	▶<예>회원가입할 때 가입날짜를 입력하지 않아도 그 당일날짜가 저장되는 경우.

----------------
check
----------------
	▶지정한 데이터만 입력 가능하다.
	▶<예>성별 입력 시 남 또는 여 만 입력되는 경우

----------------
Primary key(PK)
----------------
	▶not null, unique 의 제약조건 성질을 가진다. 즉 행과 행을 구분할 수 있는 유일한 데이터가 입력된다.
	▶차후에 foreign key에 의해 참조 당할수도 있다.
	▶하나의 테이블에 하나의 Primary key만 설정 할 수 있다. 즉 테이블당 0~1개만 줄 수 있다.
	▶[기본키], [주키] 라고도 한다.

----------------
foreign key(FK)
----------------
	▶Primary 키에 존재하는 데이터만 삽입될 수 있다. (=Primary 키를 참조하는 키다.)
	▶<주의>예외적으로 null 값은 입력 가능하다. 즉, 데이터가 입력되지 않을수도 있다.
	▶하나의 테이블에 0개 이상의 foreign key를 설정할 수 있다.
	▶table과 table간의 관계를 설정하는 키다.
	▶[참조키], [외래키], [관계키], [종속키] 라고도 한다.


(예시)

									employee
	=================================================
	e_name    dep_name    salary    jikup   jumin_num
	=================================================
	사오정     관리부     5000      대리    901225-1234543
	저팔계     영업부     6000      과장    ~
	손오공     자재부     7000      부장    ~
	사오정     관리부     5000      대리    901225-1234543



	PK							employee
	=================================================
	e_no    e_name    dep_name    salary    jikup
	=================================================
	1       사오정     관리부     5000      대리
	2       저팔계     영업부     6000      과장
	3       손오공     자재부     7000      부장
	4       사오정     관리부     5000      대리


(예시)

	dept
=====================================================
dep_no(PK)     dep_name
=====================================================
10             관리부
20             자재부
30             홍보부
40             사업부


                  employee
===============================================================
e_no(PK)     e_name    dep_no(FK)    salary  jikup     mgr_emp_no(FK)
===============================================================
1         사오정       10            5000     대리       3
2         저팔계       20            6000     과장       3
3         손오공       30            7000     부장       null
4         사오정       40            5000     대리       2


            customer
=====================================================
c_no(PK)     c_name    phone  e_no(FK)
=====================================================
1         사오순        ~     2
2         저팔순        ~     4
3         손오순        ~     1
4         사오순        ~     2


OX문제 20210611.md 참고.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<11> 시퀀스(sequence) 가 뭡니까?	(입50%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[고유 일련 번호]를 생성해서 제공하는 객체이다. 일종의 [일련 번호 생성기] 이다.
●주로 하나의 테이블에서 PRIMARY KEY 로 지정된 컬럼명에 입력될 [일련 번호] 값을 생성한다.
●<비유>은행에서 번호표 뽑는 기계와 동일한 기능을 가진다.
--------------------------
●시퀀스 생성 SQL 구문
--------------------------
	-----------------------------------
	create sequence 시퀀스명
		start with 시작값
		increment by 증가값
		minvalue 최소값
		maxvalue 최대값;
	-----------------------------------
	예
	-----------------------------------
	create sequence sq_emp
		start with 1
		increment by 1
		minvalue 1
		maxvalue 9999;
	-----------------------------------
	create sequence sq_emp
		start with 999
		increment by -1
		minvalue 1
		maxvalue 9999;
	-----------------------------------
--------------------------
●증가된 새 일련번호 얻는 SQL 구문
--------------------------
	시퀀스명.nextval
--------------------------
●마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
--------------------------
	시퀀스명.curval
--------------------------
●시퀀스 삭제 SQL 구문
--------------------------
	drop sequence 시퀀스명;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<12> 오라클을 연습하려면 어떤 SW를 설치해야 합니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다.
<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다,
	▶IP            => ip주소 또는 localhost
	▶사용자        => system
	▶암호          => 설정암호
	▶SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<13> system 계정으로 접속하니 쓸 때 없는 테이블이 많아 번거롭네요.
     system 계정과 동일한 권한을 가지는 새로운 계정을 만들려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
	create user king  identified by k123;
② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
	grant connect,resource,dba to king;
③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다,
	●IP            => 127.0.0.1 또는 localhost
	●사용자        => king
	●암호          => k123
	●SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<14>아래 고객 요구사항에 맞는 테이블을 만들면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	부서를 관리하고 싶어요.
		관리하고 싶은 정보는 부서명, 부서 위치 입니다.
	-----------------------------------------------------------------
	직원정보를 관리하고 싶어요
		관리하고 싶은 정보는 직원명, 직급, 입사일, 소속부서명, 연봉, 주민번호, 전화번호, 연봉등급, 직속상관명 입니다.
	-----------------------------------------------------------------
	고객정보를 관리하고 싶어요
		관리하고 싶은 정보는 고객명, 전화번호, 주민번호, 담당직원명 입니다.
	-----------------------------------------------------------------
	연봉등급을 관리하고 싶어요
		관리하고 싶은 정보는 연봉등급, 등급별최소연봉, 등급별최대연봉
	-----------------------------------------------------------------

	SQL_02_teacher0615.sql 에 정답 있음.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<15> employee 테이블에서 모든 컬럼, 모든행의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	select * from employee;
	-----------------------------------------------------------------
	select emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no from employee;
	-----------------------------------------------------------------
	select
		emp_no
		, emp_name
		, dep_no
		, jikup, salary
		, hire_date, jumin_num
		, phone_num
		, mgr_emp_no

	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<16> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 컬럼의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no, emp_name, jikup, salary, hire_date
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<17> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 을 검색하면서
	별칭(=alias)을 즉, 헤더를 사원번호, 직원명, 직급, 연봉, 입사일로 하고
	연봉에 '만원' 이란 문자를 붙여 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	-----------------------------------------------------------------
	select
		emp_no             as "직원번호"
		, emp_name         as "직원명"
		, jikup            as "직급"
		, salary||'만원'   as "연봉"
		, hire_date        as "입사일"
	from
		employee;
	-----------------------------------------------------------------
		<참고> as 생략이 가능하다.
		<참고> 별칭에 공백이 없으면 "" 도 생략이 가능하다. 그치만 무조건 사용하는것이 좋다. 일단 한놈만 패자...
		<참고> 오라클에서 연결 연산자는 + 가 아니라 || 이다. 자바와 다르다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액을 검색하면? (세금은 연봉의 12%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	select
		emp_name               as "직원명"
		, jikup                as "직급"
		, salary*0.12||'만원'   as "세금"
		, salary*0.88||'만원'   as "실수령액"
	from
		employee;
	-----------------------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<19> employee 테이블에서 직급을 중복없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select distinct jikup from employee;
	-----------------------------------------------
	select unique jikup from employee;
	-----------------------------------------------
	select distinct(jikup) from employee;
	-----------------------------------------------
	select unique(jikup) from employee;
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<20> employee 테이블에서 부서번호와 직급을 중복 없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select distinct dep_no, jikup from employee;
	select unique dep_no, jikup from employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<21> employee 테이블에서 연봉이 3000 이상인 직원을 검색해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select * from employee where salary>=3000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<22> employee 테이블에서 연봉 오름차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by salary asc;
	-----------------------------------------------
	select * from employee order by salary ;
	-----------------------------------------------
	select * from employee order by 5 asc; -- 컬럼명 위치번호.
	-----------------------------------------------
	select * from employee order by 5 ;     -- asc 생략 가능.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<23> employee 테이블에서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  -----------------------------------------------
	select * from employee order by salary desc;  -- 내림차순
  -----------------------------------------------
	select * from employee order by 5 desc;
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<24> employee 테이블에서 부서번호 오름차순을 유지하면서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by dep_no asc, salary desc;
	-----------------------------------------------
	select * from employee order by dep_no , salary desc;  -- asc 생략 가능하지만 혼동될 가능성이 높다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<25> employee 테이블에서 직급이 높은 순서 나열해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	select * from employee order by jikup desc;
	-----------------------------------------------
	select * from employee order by jikup asc;
	-----------------------------------------------
	위 답은 모두 잘못된것임.
	직급순서는 인간이 생각하는 기준이지 오라클의 단순한 정렬개념하고는 다르다.
	추후 조건문을 써서 정렬의 기준을 바꾸어야 답이 나온다. 나중에 합시다.
	그래도 알고 싶다면 아래가 답이다.
	-----------------------------------------------
	select * from employee order by decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4), salary desc; -- 직급순서와 연봉순서. 복합.
	-----------------------------------------------
	<명심> 고객의 요구 사항을 보고 select 문을 작성하는것도 중요하지만
	이미 작성된 select 문을 보고 고객의 요구 사항을 알아내는 것도 중요하다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<26> employee 테이블에서 부장만 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup=='부장';   -- 오라클은 '==' 은 없다.
	select * from employee where jikup='부장';    -- 이것이 정답.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<27> employee 테이블에서 20번 부서의 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<28> employee 테이블에서 20번 부서 또는 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 or jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<29> employee 테이블에서 과장 중에 연봉 3400 이상을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary>=3400 and jikup='과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<30> employee 테이블에서 실수령 액이 4000만원이상 받는 직원을 검색하면? 단, 세금이 12% 라고 가정하자.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary*0.88>=4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서 부서번호가 내림차순이면서
	사장이 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by salary*0.12 desc, dep_no desc where jikup!='사장';
	select * from employee where jikup != '사장' order by salary*0.12 desc , dep_no desc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<32> employee 테이블에서 20번 부서 중에 연봉 2000~3000 사이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and salary>=2000 and salary<=3000;
	select * from employee where dep_no=20 and salary between 2000 and 3000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<33> employee 테이블에서 직속 상관이 없는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<34> employee 테이블에서 직속 상관이 있는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is not null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<35> 오라클 4대 천왕?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	내장함수               => 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴한다.
	join (조인)            => 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
	subquery (서브쿼리)    => SQL 구문안의 select 문
	group by              => 통계관련 작업

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<36> employee 테이블에서 [최소 연봉]. [최대 연봉], [평균 연봉], [연봉총합], [총인원수]을 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select

  	min( salary )    as "최소연봉"  -- salary 컬럼에서 최소값을 리턴
  	,max( salary )   as "최대연봉"  -- salary 컬럼에서 최대값을 리턴
  	,avg( salary )   as "평균연봉"  -- salary 컬럼에서 평균값을 리턴.
                                 -- <조심>avg 사용 시 null 있으면 더할때 빠지고 나누는 개수에서도 빠진다.
  	,sum( salary )   as "연봉총합"  -- salary 컬럼에서 총합을 리턴.
  	,count( salary ) as "총인원수"  -- count(*) 는 총행의 개수
	from
  	employee;
	-----------------------------------------------------
	min, max, avg, sum, count 함수들을 [그룹함수] 또는 [통계함수] 라고 부르기도 한다.
	그룹지어서 연산을 하는 함수이기 때문이다.
	그룹함수들은 주로 group by 와 같이 많이 사용한다.
	-----------------------------------------------------
	min, max, avg, sun, count 함수들은 null 값은 제외하고 계산한다.
	-----------------------------------------------------
	count(컬럼명) => 컬럼안의 null 아닌 데이터의 개수를 리턴한다.
	count(*)     => 행의 개수를 리턴한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<37> 아래 SQL 구문은 무슨 문제의 답인가?
     select count(emp_no) from customer;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	담당 직원이 있는 고객의 명수는?
	emp_no 컬럼안의 담당 직원의 직원번호이므로 직원번호의 개수는 결국  담당직원이 있는 고객의 명수가 된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<38> 고객을 담당하고 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct emp_no) from customer;
	-----------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39> 직속상관이 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(mgr_emp_no) from employee;
	-----------------------------------------------------
	<주의>mgr_emp_no 컬럼안의 데이터가 뭔지 먼저 파악해야한다. 바로 직속 상관의 직원번호 이다.
	-----------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39-1> 부하직원이 있는 직원의 명수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct mgr_emp_no) from employee;
	-----------------------------------------------------
	distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거
	-----------------------------------------------------
	<주의>count에는 업무적 특징(고객요구사항)이 숨어 있어 조심히 날려야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<40> employee 테이블에서 [직원번호], [직원명], [생일월-생일일] 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no                                               "직원번호"
		,emp_name                                            "직원명"
		,substr(jumin_num,3,2)||'-'||substr(jumin_num,5,2)   "생일월일"  -- 세번째에서 두개 출력
	from
		employee;
	-----------------------------------------------------
	*****substr(컬럼명, 복사할시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기. 엄청난 사용빈도를 자랑한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력하면?
	단, 주민번호는 901225-2****** 형태로 출력하세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		cus_no
		,cus_name
		,tel_num
		,substr(jumin_num,1,6)||'-'||substr(jumin_num,7,1)||'******'
		,emp_no
	from
		customer;
	-----------------------------------------------------
	<주의>모든 행이란 말이 나오면 where 절이 없다.
	-----------------------------------------------------
	*****substr(컬럼명, 복사할시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기. 엄청난 사용빈도를 자랑한다.
	-----------------------------------------------------
	|| => 좌우의 문자열을 붙이는 연산자, 즉 연결 연산자이다.
	<조심> 오라클에서 + 는 연결연산자가 아니라 사칙연산자 이다.
	'tom'||'my'
	'tom'||123   -> 	'tom'||'123'   -> 	'tom123'


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<42> customer 테이블에서 고객번호, 고객명, 담당직원번호 를 출력하면?
	단, 담당직원번호가 없으면 null 출력하지 말고 '없음' 으로 표시 하삼!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		cus_no
		,cus_name
		,nvl(emp_no||'','없음')
	from
		customer;
	-------------------------------------------
	nvl( 컬럼명, null값일때 대체데이터)
	-------------------------------------------
	=>컬럼명 안의 데이터가 null 이 아니면 그냥 리턴하고
	null 이면 null값일체 대체데이터 를 리턴하는 [null 처리 내장함수]이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부 를 출력하면?
	단, 직원번호가 있으면 '있음', 없으면 '없음'으로 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
  	cus_no
  	,cus_name
  	,nvl2(emp_no,'있음', '없음')
	from
  	customer;
	-------------------------------------------
	nvl2( 컬럼명, null값아닐때대체데이터, null값일때대체데이터 )
	-------------------------------------------
	=>컬럼명 안의 데이터가 null 이 아니면 null값아닐때 대체데이터 출력하고
 	null 이면 null값일체 대체데이터 를 리턴하는 [null 처리 내장함수]이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<44> employee 테이블에서 직원번호, 직원명, 직급, 성별 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
  	emp_no
  	,emp_name
  	,jikup
  	,case
    	substr(jumin_num,7,1)
    	when '1' then '남'
    	when '3' then '남'
    	when '2' then '여'
    	when '4' then '여'
  	end
	from
  	employee;
	--------------------------------------------------
	select
  	emp_no
  	,emp_name
  	,jikup
  	,case
    	substr(jumin_num,7,1)
    	when '1' then '남'
    	when '3' then '남'
    	else '여'
  	end
	from
  	employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '남'
			when substr(jumin_num,7,1)='3' then '남'
			else '여'
		end
	from
		employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','남'
		,'3','남'
		,'여'
		)
	from
		employee;
	***************************************************
	case ~ end 구문의 패턴 설명
	***************************************************
	<패턴1>--------------------------------------------------
	case 컬럼명
		when 데이터1 then 리턴값1
		when 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	--------------------------------------------------
		컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
		컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
		~
		그외에는 리턴값n 을 리턴하기
	<패턴2>--------------------------------------------------
	case
		when 컬럼명 = 데이터1 then 리턴값1
		when 컬럼명 = 데이터2 then 리턴값2
		~
		else 리턴값n
	end
	--------------------------------------------------
		컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
		컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
		~
		그외에는 리턴값n 을 리턴하기
	--------------------------------------------------
	패턴2 에서 `=` 대신에 필요에 따라 `>=, >, <, <=, !=` 등의 비교연산자도 사용할 수 있다.
	필요에 따라 `else 리턴값n` 는 생략 될 수 있다.
	***************************************************
	decode(~) 구문의 패턴 설명
	***************************************************
		decode(
			컬럼명
			, 비교데이터1, 리턴값1
			, 비교데이터2, 리턴값2,
		  , ~
			, 리턴값n
		)
	--------------------------------------------------
	컬럼명 안의 데이터가 데이터1 과 같으면 리턴값1 을 리턴
	컬럼명 안의 데이터가 데이터2 과 같으면 리턴값2 을 리턴
	~
	그외에는 리턴값n 을 리턴하기
	--------------------------------------------------
	필요에 따라 리턴값n 는 생략될수 있다.
	--------------------------------------------------
	decode 단점
		=> 같다라는 경우에만 사용된다.
		=> 오라클에서만 사용되는 오라클 전용함수이다. case ~ end 구문은 모든 DB에서 사용가능하다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<45> employee 테이블에서 직원번호, 직원명, 직급, 출생년도(4자리) 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end ||substr(jumin_num,1,2) "출생년도"
	from
		employee;
	--------------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','19'
		,'2','19'
		,'20'
		) ||substr(jumin_num,1,2) "출생년도"
	from
		employee;
	---------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<46> employee 테이블에서 직원번호, 직원명, 직급, 출생년대(4자리) 를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_no
		,emp_name
		,jikup
		,case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end ||substr(jumin_num,1,1)||'0년대' "출생년대"
	from
		employee;

	----------------------------------------------
	select
		emp_no
		,emp_name
		,jikup
		,decode(substr(jumin_num,7,1)
		,'1','19'
		,'2','19'
		,'20'
		) ||substr(jumin_num,1,1)||'0년대' "출생년도"
	from
		employee;
	----------------------------------------------
	<참고>
	년도 => 1년 단위
	년대 => 10년 단위

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<47> employee 테이블에서 나이순으로 출력하면? 연장자가 먼저 나오도록.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
	 *
	from
		employee
	order by
		case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end || substr(jumin_num,1,6)

		asc; --asc는 생략 가능하다.
	----------------------------------------------
	아래 처럼하면 안된다. 2000년 생이 먼저 나온다. 2000년 생은 주민번호가 00 으로 시작한다.
	----------------------------------------------
	select * from employee order by jumin_num asc;
	----------------------------------------------
	order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case 가 끌어 안아서 다른 형태로 바꾼 것이다.
	----------------------------------------------
	order by 구문의 패턴
	----------------------------------------------
		----------------------------------------------
		order by 컬럼명|컬럼순서번호|컬럼알리아스 [asc]|desc;
		----------------------------------------------
		컬럼알리아스 = 컬럼을 별칭 헤더.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<48> employee 테이블에서 직급순서대로 정렬하여 모든 컬럼을 보이면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	order by
		case jikup
			when '사장' then 1
			when '부장' then 2
			when '과장' then 3
			when '대리' then 4
			when '주임' then 5 else 6
		end
		asc;
	----------------------------------------------
	--decode로 변경--
	select * from employee
		order by
			decode( jikup
				,'사장', 1
				,'부장', 2
				,'과장', 3
				,'대리', 4
				,'주임', 5
				,6
			)
			asc;
	----------------------------------------------
			select * from employee
				order by
					decode( jikup
						,'사장', 6
						,'부장', 5
						,'과장', 4
						,'대리', 3
						,'주임', 2
						,1
					)
					desc;
		----------------------------------------------
		order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case 가 끌어 안아서 다른 형태로 바꾼 것이다.
		----------------------------------------------
		정렬 시 사장은 1로 보고, 부장은 2로 보고, 과장은 3으로 보고, 대리는 4로 보고, 주임은 5로 보고 기타는 6으로 보고 오름차순으로 정렬한다. 즉, 직급을 정수로 바꿔서 정렬을 한 것이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49> employee 테이블에서 직원번호, 직원명, 입사일(년-월-일(요일) 시분초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		, emp_name
		, to_char(hire_date,'YYYY-MM-DD(DAY) Q AM HH:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
		, to_char(hire_date,'YYYY-MM-DD(DAY) HH24:MI:SS' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	----------------------------------------------
	to_char(날짜또는숫자컬럼명, '리턴시원하는문자패턴')
	----------------------------------------------
		지정한 날짜 또는 숫자를 원하는 출력문자패턴 으로 바꾸어 주는 변환함수의 일종
		리턴시 원하는 문자패턴
			YYYY   => 년도 4자리
			MM     => 월 2자리
			DD     => 일 2자리
			AM HH  => 오전|오후 1~12사이의 시간
			HH24   => 0~23 사이의 시간
			MI     => 0~59 사이의 분
			SS     => 0~59 사이의 초
			DAY    => 영문 요일 풀네임
			DY     => 영문 요일 약어
			Q      => 1~4 사이의 분기

	----------------------------------------------
	to_char(hire_date,'YYYY-MM-DD')
	----------------------------------------------
		hire_date 컬럼안의 데이터를 년-월-일 패턴의 문자열로 바꾸어 리턴하라.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49-1> employee 테이블에서 직원번호, 직원명, 입사일(X년-X월-X일(요일) X분기 X시X분X초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	1999년-12월-25일(화) 4분기 11시 10분 22초

	select
		emp_no
		,emp_name
		,to_char(hire_date, 'YYYY')||'년'
		|| to_char(hire_date, 'MM')||'월'
		|| to_char(hire_date, 'DD')||'일'
		|| to_char(hire_date, '(DY)' , 'NLS_DATE_LANGUAGE = Korean')
		|| to_char(hire_date, 'AM HH')||'시'
		|| to_char(hire_date, 'MI')||'분'
		|| to_char(hire_date, 'SS')||'초'
	from
		employee;
	----------------------------------------------
	select
		emp_no
		, emp_name
		, to_char(hire_date,'YYYY"년-"MM"월-"DD"일" (DY) Q"분기" HH"시"MI"분"SS"초"' , 'NLS_DATE_LANGUAGE = Korean')
	from
		employee;
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<50> employee 테이블에서 직원번호, 직원명, 나이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		, emp_name
		, to_number(  to_char(sysdate,'YYYY')  )
		 - to_number(
		  case
 			substr(jumin_num,7,1) when '1' then '19'
 			when '2' then '19' else '20' end ||substr(jumin_num,1,2)
		 ) + 1  ||'세'                 "나이"
	from
		employee;
	----------------------------------------------
	select
		emp_no
		, emp_name
		, 현재년도
		  -
			출생년도+1||'세'
	from
		employee;
	----------------------------------------------
	to_number(숫자문자내장된컬럼명) => 컬럼명 안의 숫자 문자를 숫자로 변경하는 변환함수
	----------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<51> employee 테이블에서 직원번호, 직원명, 근무년차를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		,emp_name "직원명"
		, 오늘날짜에서 입사일날짜까지의 차이를 일수로 구하고 365 나눈 후 소수 첫째 자리에서 무조건 올림 "근무년차"
	from
		employee;
	----------------------------------------------
	select
		emp_no                                       "직원번호"
		, emp_name                                   "직원명"
		, ceil((sysdate - hire_date)/365)||'년차'     "근무년차"
	from
		employee;
	----------------------------------------------
	오라클은 날짜-날짜 의 결과값은 날짜차이만큼의 일수이다.
	----------------------------------------------
	ceil(~)  => 소수 첫째 자리에서 무조건 올림해서 리턴하는 수학 함수의 일종이다.
	floor(~) => 소수 첫째 자리에서 무조건 내림해서 리턴하는 수학 함수이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		,emp_name "직원명"
		, floor(
		  (
			to_number(to_char(sysdate,'YYYY'))
		 	- to_number(
		  	case
 					substr(jumin_num,7,1) when '1' then '19'
 					when '2' then '19' else '20'
				end ||substr(jumin_num,1,2)
		 		) + 1
		 	) * 0.1
		 )  ||'0대'     "연령대"
	from
		employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53> employee 테이블에서 직원번호, 직원명, 100일잔치날짜를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no "직원번호"
		, emp_name "직원명"
		, to_char(
				to_date(
					case substr(jumin_num,7,1) when '1' then '19'
					when '2' then '19' else '20' end||substr(jumin_num,1,6)
					, 'YYYYMMDD'
				) + 100
				, 'YYYY-MM-DD'
			)                           "100일잔치날짜"
	from
		employee;

=> 여기서 요일 추가하려면 (DAY) 넣으면됨. 한글형식이려면 'NLS_DATE_LANGUAGE = Korean' 붙여넣으면 됨.
	----------------------------------------------
	날짜+정수   => 날짜에 정수만큼의 일수를 더한 날짜를 리턴.
	날짜-정수   => 날짜에 정수만큼의 일수를 뺸 날짜를 리턴.
	날짜1-날짜2 => 날짜1 과 날짜2 까지의 차이를 일수로 리턴. 일수 양수가 날짜1이 날짜2 보다 큰거다
	----------------------------------------------
	날짜1+날짜2 => 이런거 없다.......
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53-1> 개강일이 2021년5월12일 이고 종강일이 2021년11월10일 이다. 며칠 동안 학원 생활을 하나?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		to_date('20211110', 'YYYYMMDD')
		-
		to_date('20210512', 'YYYYMMDD')
	from
		dual;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<54> employee 테이블에서 직원번호, 직원명, 현재나이, 입사일당시나이 를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                     "직원번호"
		,emp_name                  "직원명"
		,to_number(to_char(sysdate, 'YYYY'))
			- to_number(
				case substr(jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
				||substr(jumin_num,1,2)
			) + 1 ||'세'               "현재나이"
		,to_number(to_char(hire_date, 'YYYY'))
			- to_number(
				case substr(jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
				||substr(jumin_num,1,2)
			) + 1 ||'세'               "입사일당시나이"
	from
		employee;
	----------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<55> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올생일날(년-월-일), 생일까지남은일수 를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                                                 "직원번호"
		, emp_name                                             "직원명"
		, jumin_num                                            "주민번호"
		, 올해생일날짜-지금이시각날짜 = 다가올 생일날
		, 생일까지남은일수
	from
		employee;
	----------------------------------------------
	select
	  emp_no                                                 "직원번호"
	  , emp_name                                             "직원명"
	  , jumin_num                                            "주민번호"

		,case when
				to_date(
	    		to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
					, 'YYYYMMDD'
	  		)
				-
				sysdate
				>=0
			then	--올해 생일을 년-월-일 로 리턴하는 식
				to_char(
						to_date(
								to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
								, 'YYYYMMDD'
						)
						,'YYYY-MM-DD'
				)
			else  --내년 생일을 년-월-일 로 리턴하는 식
				to_char(
						to_date(
								to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
								, 'YYYYMMDD'
						)
						,'YYYY-MM-DD (dy)'
				)
		end    "다가올생일날"
		,ceil(
		case when
				to_date(
					to_number(to_char(sysdate,'YYYY'))||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
				>=0
		then
				to_date(
				to_number(to_char(sysdate,'YYYY'))||substr(jumin_num,3,4)
				, 'YYYYMMDD'
				)
				-
				sysdate
		else
				to_date(
					to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
		end
		)
		 "생일까지남은일수"
	from
	  employee
	order by 5 asc;  -- order by "생일까지남은일수" asc; 별칭으로 써도 적용된다.
	--------------------------------
	생일까지 남은일수 계산 방법
	--------------------------------
		만약 올해생일-지금날짜 값이 양수면 생일이 안지났으므로 올해생일날짜-지금날짜면 된다.
		만약 올해생일-지금날짜 값이 음수면 생일이 지났으므로 내년생일날짜-지금날짜면 된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<56> employee 테이블에서 직원번호, 직원명, 직급, 연봉(xxx,xxx,xxx만원) 를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		  emp_no                                    "직원번호"
		  , emp_name                                "직원명"
		  , jikup                                   "직급"
			, to_char(salary, '999,999,999')||'만원'  "연봉"
	from
		employee;
	-------------------------------------------------------
	to_char(salary, '999,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 `,` 를 삽입해서 문자로 리턴하기
	                                  만약 각 9 자리에 대응하는 숫자 없으면 화면에 출략이 안된다.
	-------------------------------------------------------
	to_char(salary, '099,999,999') => salary 컬럼안의 숫자를 3자리마다 끊어서 `,` 를 삽입해서 문자로 리턴하기
																		맨앞에 0이 있으면 그자리가 비면 0이 대체된다. 따라서 나머지도 9이어도 다 0으로 대체가 된다.
	-------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<57> employee 테이블에서 수요일에 태어난 직원을 검색하라 (새로추가)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
to_char(
		to_date(
			case substr(jumin_num,7,1) when '1' then '19'
			when '2' then '19' else '20' end||substr(jumin_num,1,6)
			, 'YYYYMMDD'
		)
		, 'DY'
		, 'NLS_DATE_LANGUAGE = Korean'
	) = '수';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'DAY'
		,'NLS_DATE_LANGUAGE = Korean'
)
= '수요일';
--------------------------------------------------
select * from employee
where
to_char(
	to_date(
      decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6), 'YYYYMMDD'
		)
		,'D'
		,'NLS_DATE_LANGUAGE = Korean'
)
= '4';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<58> employee 테이블에서 70년대생 남자 직원을 검색하라 (새로추가)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select * from employee
	where
		substr(jumin_num,1,1) = '7'
		and
		substr(jumin_num,7,1) = '1' ;
	--------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<59> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
	(substr(jumin_num,1,1) = '6'
	or
	substr(jumin_num,1,1) = '7'
	)
	and
	(substr(jumin_num,7,1) = '1'
	or
	substr(jumin_num,7,1) = '3'
	);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<60> employee 테이블에서 오래 근무한 직원이 먼저 나오게 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	order by
		(sysdate-hire_date)
	desc;
	---------------------------------------------
	sysdate-hire_date => 지금날짜 - 입사일. 날짜에서 날짜를 빼면 차이만큼 일수를 리턴한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<61> employee 테이블에서
 직원번호, 직원명, 근무일수, 근무개월수, 입사후 5개월후 날짜(년-월-일), 입사한달의마지막날짜(년-월-일), 입사한날짜에서돌아오는일요일날짜(년-월-일) 검색하면?
 단, 근무일수는 소수 2자리에서 반올림 하삼
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                                         "직원번호"
		,emp_name                                      "직원명"
		,round(sysdate-hire_date, 1)                   "근무일수"
		,months_between(sysdate,hire_date)             "근무개월수"
		,to_char(add_months(hire_date,5), 'YYYY-MM-DD')  "입사후5개월후날짜"
		,to_char(last_day(hire_date), 'YYYY-MM-DD')  "입사한달의마지막날짜"
		,to_char(next_day(hire_date,1), 'YYYY-MM-DD') "입사한날짜에서돌아오는일요일날짜"

 from
 	employee;
	*********************************************
	날짜함수 정리 (리턴값의 자료형을 조심하자)
	*********************************************
		---------------------------------------------
		months_between(날짜1, 날짜2) => 날짜1에 날짜2의 차이를 개월수로 리턴하기
		---------------------------------------------
	  add_months(날짜1, 개월수) => 날짜에 개월수 만큼 더한 날의 날짜를 리턴하기
		---------------------------------------------
		last_day(날짜) => 날짜가 속한 달의 마지막 날짜를 리턴하기
		---------------------------------------------
		next_day(날짜, 요일정수) => 날짜기준으로 돌아오는 요일의 날짜를 리턴하기
		                          요일정수는 1~7(1은일 ~ 토)
		---------------------------------------------
		날짜1 - 날짜2 => 날짜1 과 날짜2 의 차이를 일수로 리턴하기
		---------------------------------------------
		날짜 + 정수 => 날짜에다 정수만큼의 일수를 더한 만큼의 날의 날짜를 리턴하기
		---------------------------------------------
		날짜 - 정수 => 날짜에다 정수만큼의 일수를 뺀만큼의 날의 날짜를 리턴하기
		---------------------------------------------
	*********************************************

	round(숫자저장컬럼명, 반올림한 후 보여지는 소수자리수)
	=> round(sysdate-hire_date, 1) => 소수 둘째자리에서 반올림한 결과 리턴

	trunc(숫자저장컬럼명, 버린 후 보여지는 소수자리수)
	=> trunc(sysdate-hire_date, 1) => 소수 둘째자리 이후는 모두 버리고 리턴


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<62> employee 테이블에서 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<63> employee 테이블에서 직급이 과장이 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where jikup != '과장';
select * from employee where jikup <> '과장';

위의 두개는 같은 결과를 리턴하는것임.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<64> employee 테이블에서 부서번호가 10번이고 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where dep_no = 10 and jikup = '과장';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<65> employee 테이블에서 직급이 과장 또는 부장인 직원을 검색하면? (기)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where jikup = '과장' or jikup = '부장';
select * from employee where jikup in('과장', '부장');
select * from employee where jikup = any('과장', '부장');

in 은 `=` 없다.

any 왼쪽의 `=` 조심하자.

위의 세개는 같은 결과를 리턴하는것임.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<66> employee 테이블에서 10번, 20번 부서 중에 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where (dep_no = 10 or dep_no = 20) and jikup = '과장';
select * from employee where dep_no in(10, 20) and jikup = '과장';

in은 or가 먼저 연산되어서. `()` 안써도 된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<67> employee 테이블에서 담당직원이 없는 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from customer where emp_no is null;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<68> customer 테이블에서 담당직원이 있는 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from customer where emp_no is not null;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<69> customer 테이블에서 담당직원 번호가 9번이 아닌 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from customer where (emp_no != 9) or emp_no is null;
-------------------------------------------------
<주의> emp_no is null 조건도 붙이는 이유는 emp_no가 null 일 경우
emp_no != 9 조건에 포함되지 않기 때문이다.
즉, null 은 is null 또는 is not null 연산자에 의해서만 검색된다.



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<70> employee 테이블에서 연봉이 3000만원~4000 만원 사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where salary >= 3000 and salary <= 4000;
select * from employee where salary between 3000 and 4000;

<주의>
between 왼쪽에 컬럼명이 나온다.
select * from employee where between salary 3000 and 4000;  (X)
틀린것 조심하기.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<71> employee 테이블에서 연봉이 3000만원 이상 ~4000 만원 미만 사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where salary >= 3000 and salary < 4000;
select * from employee where (salary between 3000 and 4000) and salary != 4000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<72> employee 테이블에서 연봉을 5% 인상했다고 가정하고 3000 이상인 직원을  검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where salary*1.05 >= 3000


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<73> employee 테이블에서 입사일이 '1995-1-1' 이상인 직원을  검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where hire_date >= to_date('1995-1-1','YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<74> employee 테이블에서 입사일이 '1990년~1999년' 사이인 직원을  검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee
where
	hire_date >= to_date('1990-1-1','YYYY-MM-DD')
	and
	hire_date < to_date('2000-1-1','YYYY-MM-DD');
-------------------------------------------------
select * from employee where
	to_number(to_char(hire_date, 'yyyy')) between 1990 and 1999;
-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<75> employee 테이블에서 부서번호가 10번 또는 30번인 직원 중에 연봉이 3000미만이고 입사일이 '1996-01-01' 미만 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where
(dep_no = 10 or dep_no = 30)  -- '()'를 해주어서 구분확실히..!
and salary < 3000
and hire_date < to_date('1996-01-01', 'YYYY-MM-DD');
-------------------------------------------------
select * from employee where
dep_no in(10,30)
and salary < 3000
and hire_date < to_date('1996-01-01', 'YYYY-MM-DD');
-------------------------------------------------
select * from employee where
dep_no =any(10,30)
and salary < 3000
and hire_date < to_date('1996-01-01', 'YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<76> employee 테이블에서 성이 김씨인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where substr(emp_name, 1,1) = '김';
	select * from employee where emp_name like '김%';
	-----------------------------------------------
	where 컬럼명 like '패턴문자열' => 컬럼명 안의 데이터가 패턴문자열을 갖고 있으면 그 행을 검색하라
	-----------------------------------------------
	emp_name like '김%';
	-----------------------------------------------
	=> 김이 첫글자고 두번째는 무엇이와도 좋고 길이에 제한없는 문자패턴을 골라라.
	=> 문자패턴 안의 %는 무엇이 와도 좋고 길이에 제한없음의 의미이다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<77> employee 테이블에서 성이 황씨인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--------------------------------------------------
select * from employee where
	substr(emp_name, 1,1) = '황'
	and
	substr(emp_name, 1,2) != '황보';
--------------------------------------------------
select * from employee where
	emp_name like '황%'
	and
	emp_name not like '황보%';
--------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<78> employee 테이블에서 이름이 2자인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where length(emp_name) = 2;
--------------------------------------------------
length(컬럼명) => 컬럼명 안의 문자데이터의 길이를 0이상의 정수로 리턴해주는 함수


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<79> employee 테이블에서 이름이 김으로 끝나는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name like '%김';
select * from employee where substr(emp_name, length(emp_name), 1) = '김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<80> employee 테이블에서 성이 김씨이고 3글자인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where substr(emp_name, 1, 1) = '김'
and length(emp_name) = 3;

select * from employee where emp_name like '김%'
and length(emp_name) = 3;

select * from employee where emp_name like '김__'
and length(emp_name) = 3;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<81> employee 테이블에서 이름에 김이란 문자를 가진 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name like '%김%';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<82> employee 테이블에서 성이 김씨가 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name not like '김%';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<83> employee 테이블에서 이름중간에만 김이 들어간 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select * from employee where emp_name like '%김%'
and emp_name not like '김%'
and emp_name not like '%김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<84> employee 테이블에서 여자 직원을 검색하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
select * from employee where
substr(jumin_num,7,1) = '2' or substr(jumin_num,7,1) ='4';
-------------------------------------------------
select * from employee where
substr(jumin_num, 7, 1) in('2','4');
-------------------------------------------------
select * from employee where
jumin_num like '______2%' or jumin_num like '______4%'
-------------------------------------------------
select * from employee where
jumin_num not like '______1%' and jumin_num not like '______3%'
-------------------------------------------------
만약 주민번호 중간에 - 가 있다면 아래처럼 해도 된다.
-------------------------------------------------
select * from employee where
jumin_num like '-2%' or jumin_num like '-4%';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<85> employee 테이블에서 1960년대, 1970년대 출생자 중 남자만 검색하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select * from employee where
(substr(jumin_num,1,1) = '6' or substr(jumin_num,1,1) = '7')
and substr(jumin_num,7,1) = '1';
---------------------------------------------------------
select * from employee where
(substr(jumin_num,1,1) in ('6','7') and substr(jumin_num,7,1) = '1';
---------------------------------------------------------
select * from employee where
jumin_num like '6______1%' or jumin_num like '7______1%' ;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<86> 기타 함수 정리하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------
숫자함수
-----------------------------------
	-------------
	abs(n)
	-------------
		▶ 숫자 n의 절대값을 반환
	-------------
	floor(n)
	-------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 왼쪽 정수값
			소수를 버려서 작아짐.
	-------------
	ceil(n)
	-------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 오른쪽 정수값
	-------------
	round(n,m)
	-------------
		▶ 숫자 n에서 소수 m+1 자리에서 반올림한 수 리턴
	-------------
	trunc(n,m)
	-------------
		▶ 숫자 n에서 소수 m+1 자리부터 버림
	-------------
	sign(n)
	-------------
		▶ n>0 이면 1, n<0 이면 -1, n=0 이면 0을 반환
	-------------
	mod(n,m)
	-------------
		▶ n/m 후 나머지 값을 반환
	-------------
	power(n,m)
	-------------
		▶ n의 m승을 반환


-----------------------------------
문자함수
-----------------------------------
	-------------
	chr(n)
	-------------
		▶ 정수 n을 ascii(아스키) 문자기호로 리턴한다

	-------------
	uppper(s)
	-------------
		▶ 문자열 s를 대문자로 변환시켜 리턴한다

	-------------
	lower(s)
	-------------
		▶ 문자열 s를 소문자로 변환시켜 리턴한다

	-------------
	length(s)
	-------------
		▶ 문자열 s의 길이를 리턴한다

	-------------
	substr(s, n1, n2)
	-------------
		▶ 문자열 s에서 n1번째 자리부터 n2개 까지의 문자를 리턴한다
		▶ n2 생략 시 마지막까지 문자를 리턴한다
		▶ n1이 0일 경우, 1로 바꿔 실행된다
		▶ 자리수는 n>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 셈한다
		-------------
		select substr( 'You are not alone', 9, 3 ) from dual;
		select substr( 'You are not alone', 5) from dual;
		-------------
		select substr( 'You are not alone', 0, 5 ) from dual;
		select substr( 'You are not alone', -5, 2 ) from dual;
		select substr( 'You are not alone', 5, 0 ) from dual;
	-------------
	trim(s)
	-------------
		▶ 문자열 s1의 맨 좌구측의 공백을 제거하여 리턴한다
			제거 후 또 있으면 계속 제거 후 리턴한다
	-------------
	replace( s1, s2, s3 ) ***
	-------------
		▶문자열 s1에서 s2를 s3로 수정해서 리턴한다.
		▶<예> select replace(addr, '서울특별시','서울시')  from employee
		-------------------------------
		select replace( 'You are not alone', 'You', 'We' ) from dual;
		select replace( 'You are not alone', 'not' ) from dual;
		select replace( 'You are not alone', 'not', '' ) from dual;
		-------------------------------
		select translate( 'You are not alone', 'You', 'We' ) from dual;
	-------------
	initcap( s )
	-------------
		▶문자열 s에서 각 단어의 첫 문자만 대문자로 변환하고 나머지는
		  모두 소문자로 리턴한다.
		▶select  initcap( 'abc def' ) from dual;
	-------------
	lpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 오른쪽 정렬 후 왼쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select lpad( 'abc', 7, ' ' ) from dual;
	-------------
	rpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 왼쪽 정렬 후 오른쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select rpad( 'abc', 7, '#' ) from dual;
	-------------
	instr( s1, s2, n1, n2 )  ***
	-------------
		▶( s1:타겟문자, s2:찾을문자, 에서 n1:검색시작위치, n2:몇번째에서 )
		<주의>오라클에서 위치를 따질 때 시작은 0이 아니라 1이다.
		▶문자열 s1 에서 문자열 s2 가 있는 위치 반환. (자바의 indexOf(~) 와 비슷한 기능)
		select
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la' ),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1, 2),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 12, 2)
		from dual;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> join(조인) 이 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	▶2개 이상의 테이블로부터 연관성있는 [컬럼]을 복사해서 횡으로 붙이는 작업을 말한다.
	▶예> 아래 직원번호와 직원명은 employee 테이블 소속이고, 소속부서명은 dept 테이블소속이다
	-----------------------------------
	직원번호      직원명     소속부서
	-----------------------------------
	   1          홍길동      총무부

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<88> join(조인) 의 종류?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	inner join
	-------------------------------------------------
		▶조인 조건에 맞는 행만 포함하는 조인. 대부분이 내부조인이다. (=내부조인 이라고도 한다)
	-------------------------------------------------
	outer join
	-------------------------------------------------
		▶조인 조건에 만족하지 못한 행도 출력하는 조인이다. 쪼까 어렵다. 시험문제 타겟..
	-------------------------------------------------
	self join
	-------------------------------------------------
		▶1개의 테이블을 2개 이상으로 보고 하는 조인이다. 쪼까 어렵다
	-------------------------------------------------
	cross join
	-------------------------------------------------
		▶2개 이상 테이블에서 각각의 행이 모두 연결되는 조인이다. 연결 조건이 생략된다.
		▶잘 사용되지 않는 조인이다.
	-------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<89> join(조인)에는 ANSI 조인형식과 오라클 조인이 있다는데 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	▶ANSI 조인
	-------------------------------------------------
		모든 DB 업체에서 공용으로 사용되는 조인이다.
	-------------------------------------------------
	▶오라클 조인
	-------------------------------------------------
		오라클에서만 사용되는 조인이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<90> 직원번호, 직원명, 소속부서명 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	▶<주의>직원번호와 직원명은 employee 테이블 소속이고, 소속부서명은 dept 테이블 테이블 소속이다.
	▶<주의>허걱! 이거 단순한 select 가 아닌 2개 테이블로 부터 연관성 있는 [컬럼]을 복사해서 횡으로 붙이는 작업. 즉, 조인이 필요하다.
	-------------------------------------------------
	<오라클 inner 조인>테이블에 별칭을 주지 않고 조인한 것.
	-------------------------------------------------
	select
		employee.emp_no
		,employee.emp_name
		,dept.dep_name
	from
		employee, dept
	where
		employee.dep_no=dept.dep_no
	-------------------------------------------------
	<오라클 inner 조인>별칭을 붙여서 조인하여 더 간략화.
	-------------------------------------------------
		select
			e.emp_no
			,e.emp_name
			,d.dep_name
		from
			employee e, dept d
		where
			e.dep_no=d.dep_no
	-------------------------------------------------
	<ANSI inner 조인>
	-------------------------------------------------
	select
		e.emp_no
		,e.emp_name
		,d.dep_name
	from
		employee e inner join dept d
	on
		e.dep_no=d.dep_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<91> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>담당직원이 있는 고객만 출력<inner join>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	<주의>담당직원이 있는 고객만 나와야하므로 즉, 조건에 맞는 행만 나와야하므로 inner 조인이다.
	-------------------------------------------------
	오라클 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<92> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>10번부서의 담당직원이 있는 고객만 출력<inner join>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	오라클 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no and e.dep_no = 10
	-------------------------------------------------
	<주의>오라클 조인에서 where 절에 조인 조건과 행을 골라내는 조건이 같이 나올수 있다. and 로 연결하면된다.
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	where
		e.dep_no = 10
	-------------------------------------------------
	<주의>ANSI 조인에서 on 절에 조인조건을 쓰고, where 절에 행을 골라내는 조건을 쓴다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<93> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>연봉이 3000만원 이상인 담당직원이 있는 고객만 포함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no and e.salary >= 3000;
	-------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	where
		e.salary >= 3000;
	-------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<94> [직원명], [직원직급], [직원부서명], [담당고객명], [고객전화]를 출력하면? <조건>직원 이름 오름차순 정렬
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------
	오라클 조인
	-------------------------------------------------
	select
		e.emp_name	"직원명"
		,e.jikup	"직원직급"
		,d.dep_name	"직원부서명"
		,c.cus_name	"담당고객명"
		,c.tel_num "고객전화번호"
	from
		 employee e, dept d, customer c
	where
		e.dep_no=d.dep_no and e.emp_no=c.emp_no
	order by
		e.emp_name asc;
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
		e.emp_name	"직원명"
		,e.jikup	"직원직급"
		,d.dep_name	"직원부서명"
		,c.cus_name	"담당고객명"
		,c.tel_num "고객전화번호"
	from
		 (employee e inner join dept d on e.dep_no=d.dep_no)
		 inner join customer c on c.emp_no=e.emp_no
	order by
		e.emp_name asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<95> 직원명, 직원직급, 소속부서명, 연봉등급 을 출력하면? 연봉등급 오름차순, 직급높은순서 오름차순, 나이높은 순서 내림 유지 요망
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
오라클 조인
-------------------------------------------------
select
	e.emp_name	"직원명"
	,e.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연봉등급"
from
	 employee e, dept d, salary_grade s
where
	e.dep_no=d.dep_no and (e.salary>=s.min_salary and e.salary<=s.max_salary)
--	e.dep_no=d.dep_no and (e.salary between s.min_salary and s.max_salary) between을 써도 된다.
order by
	s.sal_grade_no asc
	,decode(e.jikup, '사장',1 ,'부장',2, '과장',3, '대리',4,'주임',5,6) asc
	,	case
			when substr(e.jumin_num,7,1) in('1','2') then '19'
			else '20'
		end || substr(jumin_num,1,6)
		asc;
	-------------------------------------------------
	ANSI 조인
	-------------------------------------------------
	select
	e.emp_name	"직원명"
	,e.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연봉등급"
	from
		 (employee e inner join dept d on e.dep_no=d.dep_no)
		 inner join salary_grade s on (e.salary>=s.min_salary and e.salary<=s.max_salary)
	order by
		s.sal_grade_no asc
		,decode(e.jikup, '사장',1 ,'부장',2, '과장',3, '대리',4,'주임',5,6) asc
		,	case
			when substr(e.jumin_num,7,1) in('1','2') then '19'
			else '20'
		end || substr(jumin_num,1,6)
		asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<96> 부하직원명, 부하직원직급, 직속상관명, 직속상관직급을 출력하면? <조건>상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e1.emp_name	"직원명"
	,e1.jikup	"직원직급"
	,e2.emp_name	"직속상관명"
	,e2.jikup "직속상관직급"
from
	employee e1, employee e2
where
	e1.mgr_emp_no = e2.emp_no;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<97> 직속상관명, 직속상관직급, 부하직원명, 부하직원직급을 출력하면? <조건>상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
오라클 조인
-------------------------------------------------
내가한것.
select
	e2.emp_name	"직속상관명"
	,e2.jikup "직속상관직급"
	,e1.emp_name	"직원명"
	,e1.jikup	"직원직급"

from
	employee e1, employee e2
where
	e2.emp_no = e1.mgr_emp_no;
------------------------------------ 뭐가 다른지 비교해보기.
정답.
select
	e1.emp_name	"직속상관명"
	,e1.jikup	"직속상관직급"
	,e2.emp_name	"직원명"
	,e2.jikup "직원직급"
from
	employee e1, employee e2
where
	e1.emp_no = e2.mgr_emp_no ;
-------------------------------------------------
ANSI 조인
-------------------------------------------------
select
	e1.emp_name	"직속상관명"
	,e1.jikup	"직속상관직급"
	,e2.emp_name	"직원명"
	,e2.jikup "직원직급"
from
	employee e1 inner join employee e2
	on
	 e1.emp_no = e2.mgr_emp_no;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<98> 직원명, 직원직급, 소속부서명, 연봉등급, 직속상관명, 직속상관직급, 담당고객명 을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------
오라클 조인
-------------------------------------------------
select
	e1.emp_name	"직원명"
	,e1.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연본등급"
	,e2.emp_name "직속상관명"
	,e2.jikup "직속상관직급"
	,c.cus_name "담당고객명"
from
	employee e1, dept d, salary_grade s, employee e2, customer c
where
	e1.dep_no = d.dep_no
	and (e1.salary between s.min_salary and s.max_salary)
	and e2.emp_no = e1.mgr_emp_no
	and e1.emp_no = c.emp_no;
-------------------------------------------------
ANSI 조인
-------------------------------------------------
select
	e1.emp_name	"직원명"
	,e1.jikup	"직원직급"
	,d.dep_name	"소속부서명"
	,s.sal_grade_no "연본등급"
	,e2.emp_name "직속상관명"
	,e2.jikup "직속상관직급"
	,c.cus_name "담당고객명"
from
	(((employee e1 inner join dept d on e1.dep_no = d.dep_no)
	inner join salary_grade s on e1.salary between s.min_salary and s.max_salary)
	inner join employee e2 on e2.emp_no = e1.mgr_emp_no)
	inner join customer c on e1.emp_no = c.emp_no;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<99> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>담당직원이 없는 고객도 포함(고객은 다나와야함)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------------
	<주의>담당직원이 없는 고객도 포함 하라는 얘기는 고객은 다 나오라는 말이다. 즉, outer 조인하라는 말이다.
		outer 조인은 한쪽은 다 나오라는 조인이다. 나머지는 조건에 안맞더라도 null 달고라도 나오라는 조인
	----------------------------------------------------------
	select
		c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_no "부서번호"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+);
	----------------------------------------------------------
	▶c.emp_no=e.emp_no(+) 의미
		(+)가 붙은 컬럼의 반대편 컬럼의 소속 테이블 행은 모두 나오고
		(+)가 붙은 e.emp_no 컬럼의 소속테이블 행은 조건에 맞는게 없으면 null 이라도 달고 나오라는 뜻
		c.emp_no = e.emp_no(+)
	----------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<100> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면?
<조건> 고객정보는 모두 보이고 직원정보는 10번 부서만 보일것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	********************************************************
	오라클 조인
	********************************************************
	select
		c.cus_no "고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_no "부서번호"
	from
		customer c, employee e
	where
		c.emp_no = e.emp_no(+)
		and e.dep_no(+) = 10;
	********************************************************
	---------------------------------------------------------
	<주의> outer join 에서 where 에 (+)가 붙는 놈은?
	---------------------------------------------------------
		where 절에 다나오는 메인 테이블 소속이 아닌 모든 컬럼에 붙는다.
		심지어 행을 골라내는 조건의 컬럼도 여기에 속한다.
	---------------------------------------------------------
	<세끼문제>만약 e.dep_no(+)=10 을 e.dep_no=10 로 수정하면?
	---------------------------------------------------------
		▶담당직원이 10번 부서인 고객만 포함된다.
		마치 inner join 결과 처럼 보인다.
	********************************************************
	ANSI 조인
	********************************************************
	select
		c.cus_no "고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,e.dep_no "부서번호"
	from
		customer c left outer join employee e
	on
		c.emp_no = e.emp_no and	e.dep_no = 10;
	********************************************************
	---------------------------------------------------------
	<주의> ANSI조인에서 left outer join 나오면 left outer join 왼쪽에 있는 테이블이 다나오는 테이블이다.
	---------------------------------------------------------
	<주의> ANSI조인에서 right outer join 나오면 right outer join 오른쪽에 있는 테이블이 다나오는 테이블이다.
	---------------------------------------------------------
	<세끼문제>만약 e.dep_no(+)=10 를 따로 빼내서 where e.dep_no =10 로 추가하면?
	---------------------------------------------------------
		▶where 절이 있으면 행을 골라내므로 고객이 2명만 나온다.
		▶ANSI 방식의 outer join에서는 행을 골라내는 조건도 on 절에 들어가야한다.
		만약에 where 절을 쓰면 메인테이블이 다 나오지 않을수 있다.
-

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<101> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 담당직원연봉등급을 출력하면?
<조건> 담당직원이 없는 고객도 포함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		c.cus_no "고객번호"
		,c.cus_name	"고객명"
		,c.tel_num	"고객전화번호"
		,e.emp_name	"담당직원명"
		,e.jikup	"담당직원직급"
		,s.sal_grade_no "담당직원 연봉등급"
	from
		customer c, employee e, salary_grade s
	where
		c.emp_no = e.emp_no(+)
		--and e.salary between s.min_salary(+) and s.max_salary(+)
	    and
			s.min_salary(+) <= e.salary and s.max_salary(+) >= e.salary
	order by
		c.cus_no asc;
	---------------------------------------------------------
	<주의> employee 입장에서는 메인 테이블은 customer 이고, salary_grade 테이블 입장에서는 메인테이블은 employee 이다. 메인에 딸려나오는 테이블의 컬럼에 (+)를 붙이면 된다.
	---------------------------------------------------------
	<주의>아래 처럼은 안된다. 즉, (+)를 양쪽에 붙일수는 없다.
	s.min_salary(+) <= e.salary(+) and s.max_salary(+) >= e.salary(+)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<102> 고객번호, 고객명, 고객주민번호 출력하라. 단, 연봉이 3000 이상인 담당직원이 담당한 고객이어야 한다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,c.tel_num	"고객전화번호"

from
	customer c, employee e
where
	e.salary>=3000 and e.emp_no=c.emp_no


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<103> 고객번호, 고객명, 고객주민번호 출력하라. 단 40살 이상인 담당직원이 담당한 고객이어야한다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
내가한것.
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,c.jumin_num	"고객주민번호"

from
	customer c, employee e
where
	to_number(to_char(sysdate, 'YYYY'))
	- to_number(
		case substr(e.jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end
		||substr(e.jumin_num,1,2)+1) >= 40 and e.emp_no=c.emp_no;
--------------------------------------------------------
정답.
select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,c.jumin_num	"고객주민번호"

from
	customer c, employee e
where
	c.emp_no = e.emp_no
	and
		(
			extract(year from sysdate)
			-
			extract(
					year from
					to_date(
						decode(substr(e.jumin_num,7,1), '1', '19', '2', '19', '20')
							||substr(e.jumin_num,1,6)
						,'YYYYMMDD'
					)
			)+1
		)>=40
--------------------------------------------------------
<주의>코딩 상 분명히 조인이지만 출력되는 컬럼은 한개의 테이블에서 나오는 컬럼이다. 위 코딩은 조인이 출력 목적이 아닌, 조건목적으로 사용된것이다.
--------------------------------------------------------
<추가문제>10부서 또는 30번 부서 직원이 담당하는 고객을 검색하면?
--------------------------------------------------------



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<104> 고객번호, 고객명, 담당직원번호, 담당직원명, 담당직원소속부서명, 담당직원연봉등급, 담당직원직속상관명, 담당직원직속상관직급, 직속상관연봉등급 출력하라. 단, 고객은 다 나와야하고 null은 없음 으로 표시.

조인(join)의 대표적인 문제임. 이것만 정확히 안다면 조인은 다 안다고 볼 수 있다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
`join 을 대표하는 문제`

select
	c.cus_no	"고객번호"
	,c.cus_name "고객명"
	,nvl(to_char(e1.emp_no),'없음')	"담당직원번호"
	,nvl(e1.emp_name,'없음') "담당직원명"
	,nvl(d.dep_name,'없음') "담당직원소속부서명"
	,nvl(to_char(s1.sal_grade_no),'없음') "담당직원연봉등급"
	,nvl(e2.emp_name,'없음') "담당직원직속상관명"
	,nvl(e2.jikup,'없음') "담당직원직속상관직급"
	,nvl(to_char(s2.sal_grade_no),'없음') "직속상관연봉등급"
	--,nvl(c.cus_name||'','없음')
from
	customer c, employee e1, dept d, salary_grade s1, employee e2, salary_grade s2
where
	c.emp_no = e1.emp_no(+)
	and
	e1.dep_no = d.dep_no(+)
	and
	e1.mgr_emp_no = e2.emp_no(+)
	and
	--s1.min_salary(+) <= e1.salary and s1.max_salary(+) >= e1.salary
	e1.salary between s1.min_salary(+) and s1.max_salary(+)
	and
	--s2.min_salary(+) <= e2.salary and s2.max_salary(+) >= e2.salary
	e2.salary between s2.min_salary(+) and s2.max_salary(+)
order by
c.cus_no asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<105> 직원명, 직원전화번호와 고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복하지 말것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------
union
----------------------------------------
	서로 다른 테이블의 컬럼을 종으로 붙이는 작업을 말한다.
	union 규칙
		=> 컬럼의 개수가 일치해야 한다.
		=> 붙는 컬럼의 자료형이 일치해야 한다.
----------------------------------------
select emp_name||'직원', phone from employee
union
select cus_name||'고객', tel_num from customer
----------------------------------------
union 만 쓰면 중복행을 제거한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<106> 직원명, 직원전화번호와 고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복허락
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------
select emp_name, phone from employee
union all
select cus_name, tel_num from customer
----------------------------------------
union all 을 쓰면 중복행을 허락한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<107> subquery(서브쿼리)가 뭐죠?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------------------------------
	select, insert, update, delete 구문 안에 들어 있는 또 다른 select 문을 말한다.
	------------------------------------------------------------------------------
	<주의>from 절에 나오는 select는 서브쿼리가 아니라 inline(인라인뷰)라고 부른다.
	------------------------------------------------------------------------------
	----------------------------
	서브쿼리 사용 시 주의점
	----------------------------
		select, update, delete 안의 서브쿼리는 꼭 ( )로 묶는다.
		경우에 따라 조인대신 서브쿼리를 써도 같은 결과를 낼 수 있다. 이때 join 보다 서브쿼리의 부하가 더 많이 걸린다.
		현업가면 개성마다 다르다.
	----------------------------
	서브쿼리 종류
	----------------------------
		비상관쿼리(Noncorrelated Subquery)
		----------
			[서브쿼리]와 [외부쿼리]가 연관성이 없다.
			[서브쿼리] 실행 후의 결과값을 가지고 [외부쿼리] 실행된다.

			<예> 평균 연봉 이상 받는 직원을 검색하면?
			select * from employee where salary >= (select avg(salary) from employee)
		----------
		상관쿼리(Correlated Subquery)
		----------
			[서브쿼리]와 [외부쿼리]가 연관성이 있다.
			[서브쿼리]와 [외부쿼리]가 서로 통신하면서 쿼리가 진행된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<108> 최고 연봉을 받는 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where salary = (select max(salary) from employee);
	---------------------------------------------------
	서브쿼리 select max(salary) from employee 가 먼저 실행되고 난 후 리턴되는 최고연봉을 가지고 바깥 쿼리가 실행 된다.
	위 쿼리는 비상관 쿼리이다.[서브쿼리] 실행 후의 결과값을 가지고 [외부쿼리] 실행되기 때문이다.
	<주의> ~ where salary = max(salary); -> 이렇게 하면 안된다.



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<109> 평균 연봉 이상을 받는 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where salary >= (select avg(salary) from employee)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<110> 20번 부서에서 최고 연봉자 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------------------------
	select * from employee
	where salary = (select max(salary) from employee where dep_no = 20) and dep_no = 20;
	----------------------------------------------------------------------
	아래처럼 하면 문제가 바뀐다.
	"20번 부서의 최고연봉자와 동일한 연봉을 받는 모든 직원을 검색하라" 이렇게 바뀐다.
	----------------------------------------------------------------------
	select * from employee
	where salary = (select max(salary) from employee where dep_no = 20)

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<111> [직원명], [직급], [연봉], [전체연봉에서 차지하는 비율]을 검색하라. [전체연봉에서 차지하는 비율]은 소수점 버림하고 %로 표현하라.
단, 높은 비율이 먼저 나오게 정렬하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------------------------
	select
			emp_name "직원명"
			,jikup "직급"
			,salary "연봉"
			,floor(salary / (select sum(salary) from employee) * 100) ||'%' "연봉비율"
	from
			employee
	order by
			salary/(select sum(salary) from employee)*100 desc;
	-------------------------------------------------------------------
	select
			emp_name "직원명"
			,jikup "직급"
			,salary "연봉"
			,trunc(salary / (select sum(salary) from employee) * 100, 1) ||'%' "연봉비율"   -- trunc 사용하여 소수점 조절.
	from
			employee
	order by
			salary/(select sum(salary) from employee)*100 desc;
	-------------------------------------------------------------------
	<주의>정렬할때는 소수점 컨트롤을 하지 말고 소수점이 널부러지게 하고 정렬해야 정확한 정렬이 된다.
	-------------------------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<112> 10번 부서 직원들이 관리하는 [고객번호], [고객명], [직원번호]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------------------------
<1>조인(join) 답
-------------------------------------------------------------------
select
	c.cus_no
	,c.cus_name
	,c.emp_no
from
	customer c, employee e
where
	c.emp_no = e.emp_no and e.dep_no = 10;
-------------------------------------------------------------------
<2>서브쿼리(subquery) 중 비상관쿼리 답1
-------------------------------------------------------------------
select
	cus_no "고객번호"
	,cus_name "고객명"
	,emp_no
from
	customer
where
	emp_no in(select emp_no from employee where dep_no=10)
	--emp_no = any (select emp_no from employee where dep_no=10)
	-- in 대신 any도 쓸 수 있다. `=` 을 주의해서 써주어야 한다.
-------------------------------------------------------------------
n행1열 서브쿼리 쓰면 , 자동으로 붙어서 나오게 된다.
-------------------------------------------------------------------
	in 뒤에 n행 1열의 결과가 나오는 서브쿼리가 나오면 n행 1열의 데이터가 in 뒤에 콤마(,)로 나열된다.
-------------------------------------------------------------------
<3>서브쿼리(subquery) 중 비상관쿼리 답2
-------------------------------------------------------------------
	select
		cus_no "고객번호"
		,cus_name "고객명"
		,emp_no
	from
		customer
	where
		emp_no = any(select emp_no from employee where dep_no=10)
-------------------------------------------------------------------
<4>서브쿼리(subquery) 중 상관 쿼리 답1
-------------------------------------------------------------------
select
	c.cus_no
	,c.cus_name
	,c.emp_no
from
	customer c
where
	(select e.dep_no from employee e where c.emp_no=e.emp_no) = 10;
-------------------------------------------------------------------
<5>서브쿼리(subquery) 중 상관 쿼리 답2
-------------------------------------------------------------------
select
	c.cus_no
	,c.cus_name
	,c.emp_no
from
	customer c
where
	(select count(*) from employee e where c.emp_no = e.emp_no and e.dep_no=10)>0;



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<113> 평균 연봉 이상이고 최대 연봉 미만의 [직원명], [연봉], [전체평균연봉], [전체최대연봉]을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	emp_name "직원명"
	,salary "연봉"
	, (select avg(salary)from employee)  "전체평균연봉"
	, (select max(salary)from employee)  "전체최대연봉"
from
	employee
where
	salary>= (select avg(salary) from employee)
	and
	salary< (select max(salary) from employee);

-

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<114> 최고연봉 직원의 [직원번호], [직원명], [부서명], [연봉]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e.emp_no
	,e.emp_name
	,d.dep_name
	,e.salary

from
 dept d, employee e

where
d.dep_no = e.dep_no
and
e.salary = (select max(salary) from employee);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<115> 담당 고객이 2명 이상인 [직원번호], [직원명], [직급]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e.emp_no
	,e.emp_name
	,e.jikup
from
	employee e
where
	(select count(*) from customer c where e.emp_no=c.emp_no) >=2;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<116> [직원번호], [직원명], [소속부서명]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------------------------------------
조인(join) 답
-----------------------------------------------------------------
select
	e.emp_no    "직원번호"
	,e.emp_name "직원명"
	,d.dep_name "소속부서명"
from
	employee e, dept d
where
	e.dep_no = d.dep_no;
-----------------------------------------------------------------
서브쿼리 답
-----------------------------------------------------------------
select
	e.emp_no    "직원번호"
	,e.emp_name "직원명"
	,(select d.dep_name from dept d where d.dep_no = e.dep_no) "소속부서명"
from
	employee e;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<117> [직원번호], [직원명], [연봉], [연봉순위]를 출력하면? 단 [연봉순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e1.emp_no    "직원번호"
	,e1.emp_name "직원명"
	,e1.salary   "연봉"
	,(select count(*)+1 from employee e2 where e2.salary>e1.salary)  "연봉순위"
from
 employee e1
order by
	4 asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<118> [직원번호], [직원명], [담당고객수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e.emp_no    "직원번호"
	,e.emp_name "직원명"
	,(select count(*) from customer c where c.emp_no = e.emp_no) "담당고객수"
from
	employee e;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<119> 애래 처럼 [부서명], [부서직원수], [부서담당고객수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	d.dep_name "부서명"
	,(select count(*) from employee e where e.dep_no = d.dep_no)||'명'  "부서직원수"
	,(select count(*) from employee e, customer c where e.dep_no = d.dep_no and e.emp_no = c.emp_no)||'명' "부서담당고객수"
from
	dept d
order by 2 desc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<120> [직원번호], [직원명], [직급], [주민번호], [직급서열순위]를 출력하면? *****
단, 직급이 같으면 나이 많은 직원이 [직급서열순위] 위이다. 그리고 [직급서열순위]를 오름차순 유지.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e1.emp_no
	,e1.emp_name
	,e1.jikup
	,e1.jumin_num
	,(select count(*)+1 from employee e2 where decode( e2.jikup
		,'사장', 1
		,'부장', 2
		,'과장', 3
		,'대리', 4
		,'주임', 5
		,6
	)|| decode (substr(e2.jumin_num,7,1), '1', '19', '2', '19', '20' )
    || substr(e2.jumin_num,1,6)
	< decode( e1.jikup
		,'사장', 1
		,'부장', 2
		,'과장', 3
		,'대리', 4
		,'주임', 5
		,6
	)|| decode (substr(e1.jumin_num,7,1), '1', '19', '2', '19', '20' )
    || substr(e1.jumin_num,1,6) )
	 "직급서열순위"
from
	employee e1
order by
	5 asc;

-----
select
	e1.emp_no      "직원번호"
	,e1.emp_name   "직원명"
	,e1.jikup      "직급"
	,e1.jumin_num  "주민번호"
	, (select count(*)+1 from employee e2 where case (e2.jikup
		when '사장' then 1
		when '부장' then 2
		when '과장' then 3
		when '대리' then 4
		when '주임' then 5 else 6
	end
	)|| case (substr(e2.jumin_num,7,1)
	 	when '1' then '19'
		when '2' then '19'
		else '20' end)
		|| substr(e2.jumin_num,1,6)
< case (e1.jikup
	when '사장' then 1
	when '부장' then 2
	when '과장' then 3
	when '대리' then 4
	when '주임' then 5 else 6
end
)|| case (substr(e1.jumin_num,7,1)
	when '1' then '19'
	when '2' then '19'
	else '20' end)
	|| substr(e1.jumin_num,1,6)
) "직급서열순위"
from
	employee e1
order by 5;
---
select
	e1.emp_no      "직원번호"
	,e1.emp_name   "직원명"
	,e1.jikup      "직급"
	,e1.jumin_num  "주민번호"
	,(
		select count(*)+1 from employee e2
		where
		decode( e2.jikup
			,'사장', 1
			,'부장', 2
			,'과장', 3
			,'대리', 4
			,'주임', 5
			,6)
		<
		decode( e1.jikup
			,'사장', 1
			,'부장', 2
			,'과장', 3
			,'대리', 4
			,'주임', 5
			,6)
		or
		(
			e2.jikup = e1.jikup
			and
			to_number(
        decode (substr(e2.jumin_num,7,1), '1', '19', '2', '19', '20' )
		    ||substr(e2.jumin_num,1,6)
      )
      <
			to_number(
        decode (substr(e1.jumin_num,7,1), '1', '19', '2', '19', '20' )
		    ||substr(e1.jumin_num,1,6)
      )
		)
	)         "직급서열순위"
from
	employee e1
order by
	5;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<121> [고객번호], [고객명], [고객전화번호], [담당직원명], [담당직원직급], [부서번호] 를 출력하면? <조건>담당직원이 없는 고객도 포함
단, 조인을 사용하지 말고 서브쿼리를 사용하십시오.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	서브쿼리 답
	---------------------------------------------
	select
	  c.cus_no     "고객번호"
	  ,c.cus_name  "고객명"
	  ,c.tel_num   "고객전화번호"
	  ,(select e.emp_name from employee e where e.emp_no = c.emp_no ) "담당직원명"
	  ,(select e.jikup from employee e where e.emp_no = c.emp_no ) "담당직원직급"
	  ,(select e.dep_no from employee e where e.emp_no = c.emp_no )"부서번호"
	from customer c;
	---------------------------------------------
	조인 답(오라클조인)
	---------------------------------------------
	select
	  c.cus_no     "고객번호"
	  ,c.cus_name  "고객명"
	  ,c.tel_num   "고객전화번호"
	  ,e.emp_name  "담당직원명"
	  ,e.jikup     "담당직원직급"
	  ,e.dep_no    "부서번호"
	from
	  customer c, employee e
	where
	  c.emp_no = e.emp_no(+)
	order by
	1 asc;
	---------------------------------------------
	조인 답(ANSI 조인)
	---------------------------------------------
	select
	  c.cus_no     "고객번호"
	  ,c.cus_name  "고객명"
	  ,c.tel_num   "고객전화번호"
	  ,e.emp_name  "담당직원명"
	  ,e.jikup     "담당직원직급"
	  ,e.dep_no    "부서번호"
	from
	  customer c left outer join employee e
	on
	  c.emp_no = e.emp_no
	order by
	1 asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<122> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 부서번호 를 출력하면? <조건>고객정보는 모두 보이고 직원정보는 10번 부서만 보일것.
단, 조인을 사용하지 말고 서브쿼리를 사용하십시오.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
---------------------------------------------
서브쿼리 답
---------------------------------------------
select
	c.cus_no     "고객번호"
	,c.cus_name  "고객명"
	,c.tel_num   "고객전화번호"
	,(select e.emp_name from employee e where e.emp_no = c.emp_no and e.dep_no=10 ) "담당직원명"
	,(select e.jikup from employee e where e.emp_no = c.emp_no and e.dep_no=10 ) "담당직원직급"
	,(select e.dep_no from employee e where e.emp_no = c.emp_no and e.dep_no=10 )"부서번호"
from customer c;
---------------------------------------------
조인 답(오라클조인)
---------------------------------------------
select
	c.cus_no     "고객번호"
	,c.cus_name  "고객명"
	,c.tel_num   "고객전화번호"
	,e.emp_name  "담당직원명"
	,e.jikup     "담당직원직급"
	,e.dep_no    "부서번호"
from
	customer c, employee e
where
	c.emp_no = e.emp_no(+) and e.dep_no(+)=10
order by
1 asc;
---------------------------------------------
조인 답(ANSI 조인)
---------------------------------------------
select
	c.cus_no     "고객번호"
	,c.cus_name  "고객명"
	,c.tel_num   "고객전화번호"
	,e.emp_name  "담당직원명"
	,e.jikup     "담당직원직급"
	,e.dep_no    "부서번호"
from
	customer c left outer join employee e
on
	c.emp_no = e.emp_no
	and e.dep_no=10
order by
1 asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<123> GROUP BY 구문이 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	▶select 절에 있는 컬럼안의 중복 데이터를 [하나로 그룹]지어 주는 역할을 한다.
	▶주로 그룹을 지어 통계를 낼때 사용한다.
	▶GROUP BY 구문 문법은 간단하나 통계를 내는 과정에서 각종 함수가 때거지로 등장한다.
		그러므로 GROUP BY 구문은 함수와의 싸움이다.

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<124> 부서별로 [부서번호], [급여합], [평균급여], [인원수]를 출력하면? 단, 평균은 소수 2째자리에서 반올림할 것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	ex)
	10     7000     2000     3
	20     8000     3000     4

	select
		dep_no                "부서번호"
		,sum(salary)          "급여합"
		,round(avg(salary),1) "평균급여"
		,count(*)             "인원수"
	from
		employee
	group by
		dep_no ;
	---------------------------------------------
	▶select 절에 일반 컬럼과 그룹함수 컬럼이 등장하면 group by 뒤에는 반드시 그룹지을 일반 컬럼이 나와야 한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<125> 직급별로 [직급], [급여합], [평균급여], [인원수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
	  jikup                 "직급"
	  ,sum(salary)          "급여합"
	  ,round(avg(salary),1) "평균급여"
	  ,count(*)||'명'       "인원수"
	from
	  employee
	group by
	  jikup ;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<126> 부서별, 직급별, [부서번호], [직급], [급여합], [평균급여], [인원수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		dep_no                "부서번호"
		,jikup                "직급"
		,sum(salary)          "급여합"
		,round(avg(salary),1) "평균급여"
		,count(*)||'명'       "인원수"
	from
		employee
	group by
		dep_no, jikup;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<127> 부서별로 직급별 [부서번호], [직급], [급여합], [평균급여], [인원수]를 출력하되 인원수는 3명 이상을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------------
	select
		dep_no                "부서번호"
		,jikup                "직급"
		,sum(salary)          "급여합"
		,round(avg(salary),1) "평균급여"
		,count(*)||'명'       "인원수"
	from
		employee
	group by
		dep_no, jikup
	having
		count(*) >= 3;
	------------------------------------------------------------
	group by 결과물에서 행을 골라낼 때에는 where 을 쓰지 말고 having 을 사용한다.
	------------------------------------------------------------
	인라인뷰를 사용하면 다음과 같이 문제를 풀 수 있다.
	------------------------------------------------------------
	select
		*
	from
	(
	select
		dep_no                DEP_NO
		,jikup                JIKUP
		,sum(salary)          TOT_SALARY
		,round(avg(salary),1) AVG_SALARY
		,count(*)             EMP_CNT
	from
		employee
	group by
		dep_no, jikup
	)
	where
		EMP_CNT >= 3
	------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<128> 부서별, 성별로  [부서번호], [성], [급여합], [평균급여], [인원수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		dep_no                 "부서번호"
		,case when substr(jumin_num,7,1) in('1','3') then '남' else '여' end "성"
		,sum(salary)           "급여합"
		,round(avg(salary),1)  "평균급여"
		,count(*)||'명'        "인원수"
	from
		employee
	group by
		dep_no, case when substr(jumin_num,7,1) in('1','3') then '남' else '여' end


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<129> 입사년도별로 [입사년도], [인원수]를 출력하고 년도별로 오름차순 하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		to_char(hire_date, 'YYYY')||'년'     "입사년도"
		,count(*)||'명'     "인원수"

	from
		employee
	group by
		to_char(hire_date, 'YYYY')
	order by 1 asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<130> 부서별로 [부서번호], [평균근무년수]를 출력하면? (근년수는 소수점 2째 자리에서 반올림할 것)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------------------
	select
		dep_no     "부서번호"
		,round(  avg( (SYSDATE - hire_date)/365 ), 1  ) ||'년'    "평균근무년수"

	from
		employee
	group by
		dep_no
	order by 1 asc;
	--------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<131> 입사분기별로 [입사분기], [인원수] 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		to_char(hire_date, 'Q')||'분기'    "입사분기"
		,count(*)||'명'                    "인원수"
	from
		employee
	group by
		to_char(hire_date, 'Q')||'분기';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<132> 입사연대별, 성별로 [입사연대], [성], [연대별입사자수] 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	substr(to_char(hire_date, 'YYYY'), 1, 3 )||'0년대'                       "입사연대"
	,decode(substr(jumin_num,7,1), '1', '남', '3', '남', '여')  "성"
	,count(*)                                                             "연대별입사자수"
from
	employee
group by
	substr(to_char(hire_date, 'YYYY'), 1, 3 )||'0년대'
	,decode(substr(jumin_num,7,1), '1', '남', '3', '남', '여')
order by "입사연대"

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<133> [직원명], [입사일](년-월-일 ~4분기 ~요일), [퇴직일](년-월-일) 출력하면? <조건>퇴직일은 입사 후 20년 5개월 10일 후
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	emp_name    "직원명"
	,to_char(hire_date, 'YYYY-MM-DD Q')|| '/4분기' || to_char(hire_date, 'DAY', 'NLS_DATE_LANGUAGE = Korean') "입사일"
	,to_char(add_months(hire_date, 5 + 20*12 ) + 10, 'YYYY-MM-DD', 'NLS_DATE_LANGUAGE = Korean') "퇴직일"
from
	employee

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<134> 직원들이 있는 부서별로 [부서번호], [부서위치], [직원수]를 출력하면? 모든 부서 다 나와라!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------
	--내가 한것.
	select
		d.dep_no          "부서번호"
		,d.loc            "부서위치"
		,count(e.emp_no)||'명' "직원수"
	from
		employee e, dept d
	where
		e.dep_no(+) = d.dep_no
	group by
		d.dep_no, d.loc
	order by 1
	-----------------------------------------------
	--강사님 정답
	select
		d.dep_no "부서번호"
		,d.loc "부서위치"
		,(select count(*) from employee e where e.dep_no = d.dep_no)||'명' "직원수"
	from
		dept d
	-----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<135> 월별로 [입사월], [인원수]를 검색하면?
	<조건>입사월 오름차순 유지하십쇼
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	to_char(hire_date, 'MM')||'월' "입사월"
	,count(emp_no)||'명' "입사인원수"
from
	employee
group by
	to_char(hire_date, 'MM')||'월'
order by
	"입사월" asc;
-----------------------------------------------
<새끼문제> 위 문제는 없는 달은 나오지 않는다.
없는 달도 포함하여, 즉 1월~12월 까지 다 나오게 하려면?
-----------------------------------------------
group by, join 사용
-----------------------------------------------
select
  m.month||'월'                      "입사월"
  ,count(e.emp_name)||'명'           "입사인원수"
from
(
select '01' "MONTH" from dual union
select '02' from dual union
select '03' from dual union
select '04' from dual union
select '05' from dual union
select '06' from dual union
select '07' from dual union
select '08' from dual union
select '09' from dual union
select '10' from dual union
select '11' from dual union
select '12' from dual
) m
,employee e
where
  to_char(e.hire_date(+), 'MM') = m.month
group by
  m.month||'월'
order by
  "입사월";
-----------------------------------------------
상관쿼리 사용
-----------------------------------------------
select
	  m.month||'월'                      "입사월"
		,(select count(*) from employee e where to_char(e.hire_date, 'MM')=m.month )    "입사인원수"
from
(
select '01' "MONTH" from dual union
select '02' from dual union
select '03' from dual union
select '04' from dual union
select '05' from dual union
select '06' from dual union
select '07' from dual union
select '08' from dual union
select '09' from dual union
select '10' from dual union
select '11' from dual union
select '12' from dual
) m


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<136> employee 테이블에서 직급순서대로 정렬하여 직급별로 [직급], [직급평균연봉], [인원수]를 검색하면?
(높은직급이 먼저 나와야함.)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	jikup                           "직급"
	,round(avg(salary),1)           "직급평균연봉"
	,count(*)||'명'                 "인원수"
from
	employee
group by
	jikup
order by
 	decode( jikup,'사장', 1,'부장', 2,'과장', 3,'대리', 4,'주임', 5, 6) asc;



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<137> 부서별 [부서번호], [부서명], [직원수], [직원이관리하는고객수]를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------------------
답1
-------------------------------------------------------------
	select
		d.dep_no          "부서번호"
		,d.dep_name       "부서명"
		,count(distinct(e.emp_no))  "직원수"
		,count(c.emp_no)           "관리고객수"
	from
		employee e, dept d, customer c
	where
		d.dep_no = e.dep_no(+)
		and
		e.emp_no = c.emp_no(+)
	group by
		d.dep_no, d.dep_name;
	-----------------------------------------------
	count(distinct e.emp_no)를 count(e.emp_no) 하면 안됨.
	distinct 안 쓰면 직원수가 중복되서 나온다.
	-----------------------------------------------

	-----------------------------------------------
	count(c.emp_no)를 count(distinct c.emp_no) 하면 안됨.
	distinct 쓰면 고객을 담당하는 직원수가 된다.
	-----------------------------------------------
-------------------------------------------------------------
답2
-------------------------------------------------------------
	select
		d.dep_no as "부서번호"
		,d.dep_name "부서명"
		,(select count(*)||'명' from employee e where e.dep_no = d.dep_no) "부서직원수"
		,(select count(*)||'명' from employee e, customer c where e.dep_no = d.dep_no and e.emp_no = c.emp_no) "담당 고객 수"
	from
		dept d;





■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<138> 퇴직일이 60세 라는 기준 하에 아래 처럼 출력하면?

-------------------------------------------------------------------------------------------------------------------------------
[직원번호], [직원명], [근무년차], [퇴직일까지 남은 년도], [생일(년-월-일 요일명)], [소속부서명], [직속상관명], [직속상관부서명]
---------------------------------------------------------------------------------  ------------  ------------  ----------------
                                 employee e1                                        dept d1      employee e2      dept d2


단, 모든 직원 다 나오고, 직급 높은 먼저 나오고 직급이 같으면 나이가 많은 사람이 나와야함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--내가 한것.
select
	e1.emp_no                                   "직원번호"
	,e1.emp_name                                "직원명"
	,ceil((sysdate - e1.hire_date)/365)||'년차' "근무년차"

  ,to_number(to_char(sysdate, 'YYYY'))
   -
   to_number((decode(substr(e1.jumin_num,7,1), '1', '19', '2', '19', '20'))
   ||substr(e1.jumin_num,1,2))+1               "나이"

	,60
	- (extract(year from sysdate)
	- to_number(decode(substr(e1.jumin_num,7,1),'1','19','2','19','20')||substr(e1.jumin_num,1,2)) +1)
	  "퇴직일까지 남은 년도"

  , to_char(to_date(case substr(e1.jumin_num,7,1)
    when '1' then '19' when '2' then '19' else '20' end
      ||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd(dy)','nls_date_language = korean' )  "생일"

	,case when
			to_date(
				to_char(sysdate,'YYYY')||substr(e1.jumin_num,3,4)
				, 'YYYYMMDD'
			)
			-
			sysdate
			>=0
		then	--올해 생일을 년-월-일 로 리턴하는 식
			to_char(
					to_date(
							to_char(sysdate,'YYYY')||substr(e1.jumin_num,3,4)
							, 'YYYYMMDD'
					)
					,'YYYY-MM-DD (dy)' , 'NLS_DATE_LANGUAGE = Korean'
			)
		else  --내년 생일을 년-월-일 로 리턴하는 식
			to_char(
					to_date(
							to_number(to_char(sysdate,'YYYY'))+1||substr(e1.jumin_num,3,4)
							, 'YYYYMMDD'
					)
					,'YYYY-MM-DD (dy)' , 'NLS_DATE_LANGUAGE = Korean'
			)
	end                                      "다가올 생일"
  ,e1.jikup                                "직급"
	,d1.dep_name                             "소속부서명"
	,e2.emp_name                             "직속상관명"
	,nvl(d2.dep_name, '---없음---')          "직속상관부서명"
from
	employee e1, dept d1, employee e2, dept d2
where
	e1.dep_no = d1.dep_no(+)
	and e1.mgr_emp_no = e2.emp_no(+)
	and e2.dep_no = d2.dep_no(+)
order by
	decode( e1.jikup,'사장', 1,'부장', 2,'과장', 3,'대리', 4,'주임', 5, 6)
  ||decode(substr(e1.jumin_num,7,1),'1','19','2','19','20')
  ||substr(e1.jumin_num,1,6);

---------------------------------------------------------------------------------
-- 강사님 정답풀이.

	select
		e1.emp_no                                                                                "[직원번호]"
		, e1.emp_name                                                                            "[직원명]"
		, ceil((sysdate-e1.hire_date)/365)                                                       "[근무년차]"
		------------------------------------------------------------------------------------------------------
		, to_number(to_char(sysdate,'yyyy'))               --현재이시각 년도
		-to_number((case substr(e1.jumin_num,7,1)          --출생년도
			when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1          "[나이]"
		------------------------------------------------------------------------------------------------------
		, 60-(to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1)
			when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1)    "[퇴직년도까지]"
		------------------------------------------------------------------------------------------------------
		, to_char(to_date(case substr(e1.jumin_num,7,1)
			when '1' then '19' when '2' then '19' else '20' end
				||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '
				||to_char(to_date(case substr(e1.jumin_num,7,1)
					when '1' then '19' when '2' then '19' else '20' end
				||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean')              "[생일]"
		------------------------------------------------------------------------------------------------------
		, e1.jikup                                                                                "[직급]"
		, d1.dep_name                                                                             "[소속부서명]"
	  , e2.emp_name                                                                             "[직속상관명]"
	  ,nvl(d2.dep_name, '---없음---')                                                           "[직속상관소속부서명]"
	from
	    employee e1, dept d1,employee e2, dept d2
	where
	    e1.dep_no  = d1.dep_no(+)
			and e1.mgr_emp_no = e2.emp_no(+)
			and e2.dep_no = d2.dep_no(+)
	order by
	    decode(e1.jikup ,'사장',1 ,'부장',2 ,'과장',3 ,'대리',4 ,5)
	    ,
			case substr(e1.jumin_num,7,1)  when '1' then '19' when '2' then '19' else '20' end ||substr(e1.jumin_num,1,6)
----------------------------------------------------------------------------------------------------------------
select
    e1.emp_no "[직원번호]"
    ,e1.emp_name "[직원명]"
    ,ceil((sysdate-e1.hire_date)/365)||'년' "[근무년차]"
    ,to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1)
        when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1||'살' "[나이]"
    ,60-(to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1)
        when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1)||'년' "[남은 퇴직년도]"
    ,to_char(to_date(case substr(e1.jumin_num,7,1)
            when '1' then '19' when '2' then '19'else '20'end
                ||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '
                ||to_char(to_date(case substr(e1.jumin_num,7,1)
                        when '1' then '19' when '2' then '19'else '20'end
                ||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean') "생일"
    ,e1.jikup    "[직급]"
    ,(select d.dep_name from dept d where d.dep_no=e1.dep_no) "[소속부서명]"
    ,nvl((select e2.emp_name from employee e2 where e1.mgr_emp_no=e2.emp_no),'없음')   "[직속상관명]"
    ,nvl((select d.dep_name from employee e2, dept d
            where d.dep_no=e2.dep_no and e1.mgr_emp_no=e2.emp_no)||'','없음')    "[직속상관부서명]"
    ,(select nvl(count(*), 0) from customer c  where c.emp_no=e1.emp_no) "[담당고객수]"
from employee e1
order by
    decode(e1.jikup ,'사장',1 ,'부장',2 ,'과장',3 ,'대리',4 ,5)
    ,
		case substr(e1.jumin_num,7,1)  when '1' then '19' when '2' then '19' else '20' end ||substr(e1.jumin_num,1,6)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<139> [인라인뷰(=Inline view)] 가 뭡니까? *****
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

from 절에 나오는 select 를 말한다.
from 절에는 테이블명이 나온다.
이 자리에 select 나올 경우 select 결과물을 테이블로 생각하면 된다.
인라인뷰는 select 결과물을 테이블로 취급하기 때문에 메모리에 부담을 준다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<140> 연봉 서열대로 직원을 검색하되 1행부터 10행까지만 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
*************************************************************
답1
*************************************************************
select
	*
from
(
select
	rownum RNUM, e.*
from
	(select * from employee order by salary desc) e
where
	rownum<=10
)
where
	RNUM>=1
*************************************************************
답2 => 미안하게도 답1 보다 2~3배 정도 느리다.
바깥쪽에선 RNUM 단순 컬럼으로 인식.
*************************************************************
select
	*
from
(
select
	rownum RNUM, e.*
from
	(select * from employee order by salary desc) e
)
where
	RNUM>=1 and RNUM<=10;
*************************************************************
-------------------------------------------------------------
오라클은 모든 select 결과물에 rownum 컬럼을 붙여준다.
이 컬럼안에는 1부터 시작하는 일련번호가 들어가 있다.
-------------------------------------------------------------
rownum 컬럼이 where 절에 들어갈 때 주의사항
-------------------------------------------------------------
	-------------------------------------------------------------
	order by 가 있을 경우 정렬된 후에 rownum 컬럼이 붙는게 아니라
	정렬되기 전에 rownum 컬럼이 붙고 난 후 정렬이 된다.
	그러므로 rownum 컬럼 안의 일련 번호 뒤엉켜버린다.
	-------------------------------------------------------------
	rownum 자리에 1이 들어가서 false 가 나오는 조건이 있다면 조건이 성립되지 않는다.
	-------------------------------------------------------------
	<예>
		where rownum<=3 (ㅇ)
		where rownum=1 (ㅇ)
		where rownum>=3 (X)
		where rownum>1 (X)
		where rownum = 2 (X)
		where rownum >=1 and rownum <=3 (ㅇ)
		where rownum >=2 and rownum <=3 (X)
-------------------------------------------------------------
인라인 뷰, 즉, from 절에 나오는 select 는 바깥쪽 select 입장에서는 테이블 처럼 생각한다.
인라인뷰 안에 rownum 컬럼이 있다면 바깥쪽 select 입장에서 안쪽 rownum 컬럼은 단순한 일반컬럼이 된다.
-------------------------------------------------------------
<참고문제> 이렇게 n행~m행 까지 검색하는 이유는?
-------------------------------------------------------------
	실제로는 select 의 결과물이 웹브라우저로 출력된다.
	만약 select 결과물이 100,000 행이면 다 보여줄 경우 웹브라우저 로딩이 걸린다.
	그러므로 1~10행 또는 1행~15행 씩 끊어서 웹브라우저로 출력되야 로딩이 걸리지 않는다. 이렇게 select 결과물에서 n행 씩 끊어서 화면에 보여주는 것은 [페이징] 처리라고 한다. --가끔 면접때 물어본다.

*************************************************************
<패턴> n행~m행 까지 검색하는 select 패턴 정리1
*************************************************************
select * from ( select rownum RNUM, zxcvb.* from (
	원하는 정렬 select 문
) zxcvb where rownum<=마지막행번호 ) where RNUM>=시작행번호;

*************************************************************
<패턴> n행~m행 까지 검색하는 select 패턴 정리2
*************************************************************
select * from ( select rownum RNUM, zxcvb.* from (
	원하는 정렬 select 문
) zxcvb) where RNUM>=시작행번호 and RNUM<=마지막행번호 ;





*************************************************************
<새끼문제> 고객을 나이 서열중 6행~10행 까지 검색하면?
*************************************************************
select * from ( select rownum RNUM, zxcvb.* from (
	select * from customer
	order by
		decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6) asc
) zxcvb where rownum<=10 ) where RNUM>=6;
*************************************************************
<새끼문제> 직원 직급 서열중 2행~5행 까지 검색하면?
*************************************************************
select * from ( select rownum RNUM, zxcvb.* from (
	select * from employee
	order by
		decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, '사원', 6) asc
) zxcvb where rownum<=5 ) where RNUM>=2;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<141> 오늘부터 10일 이후 까지 날짜 중에 토요일, 일요일, 월요일을 제외한 날의 개수를 구하면? -inline view
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select count(*) from
(
	select sysdate "XDAY" from dual
	union select sysdate+1 from dual
	union select sysdate+2 from dual
	union select sysdate+3 from dual
	union select sysdate+4 from dual
	union select sysdate+5 from dual
	union select sysdate+6 from dual
	union select sysdate+7 from dual
	union select sysdate+8 from dual
	union select sysdate+9 from dual
	union select sysdate+10 from dual
) d
where
	to_char(d.xday, 'dy', 'nls_date_language = korean')!='토'
	and to_char(d.xday, 'dy', 'nls_date_language = korean')!='일'
	and to_char(d.xday, 'dy', 'nls_date_language = korean')!='월'



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<142> 이번달 중에 토요일, 일요일을 제외한 날의 개수를 구하면? = 이번달 평일 수 구하기 -inline view
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	count(*)
from
	(
		select
				to_date(to_char(sysdate, 'YYYY-MM')||'-01', 'YYYY-MM-DD')+RNUM-1 "XDAY"
			from
			(
				select rownum RNUM from employee union select rownum+20 from employee)
				where RNUM<=to_number(to_char(last_day(sysdate), 'dd') --이번달 말일 숫자로 변경
			)
	) d
where
	to_char( d.xday, 'dy', 'nls_date_language = korean')!='토'
	and to_char(d.xday, 'dy', 'nls_date_language = korean')!='일'
	and XDAY <= last_day(sysdate)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<143> VIEW(뷰) 가 뭡니까? (기. 입. 실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	●실시간으로 select 결과물을 테이블 처럼 가장해서 보여주는 [테이블]이다. [가상 테이블]이라고도 한다.



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<144> VIEW(뷰) 특징은?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	●객체로써 저장된다. 즉 이름을 가지고 저장된다.
	●뷰도 테이블이므로 select 대상이 된다.
	●뷰의 근원이 되는 실존 테이블의 데이터가 변경된 후 뷰가 실행되면 뷰에 그대로 반영된다. (=실존 테이블과 view는 항상 동기화 한다.)
	●뷰를 가지고 또 다른 뷰를 만들 수 있다.

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<145> VIEW(뷰) 를 사용하는 목적은? ******
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------
	<1>보안성 때문이다.
	----------------------------------
		예를들어 abc 계정이 employee 테이블에서 salary 만 빼고 다보게 하려면
		salary만 뺀 select 구문을 employee_vw1 라는 이름의 view 로 만들어 저장하고
		employee_vw1 에 select 권한을 주고, employee 테이블에는 select 권한을 주지 않으면
		abc 계정이 employee 테이블에서 salary 만 빼고 다보게 할 수 있다.
	----------------------------------
	<2>join 드오가 같은 길고 복잡한 select 문장을 뷰로 만들어 테이블 처럼 사용하여 [편의성]을 제공한다.
	----------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<146> employee 테이블로부터 salary 컬럼만 제외하고 다 볼 수 있는 뷰 employee_vw1 를 생성하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

create view employee_vw1 as
	select
		emp_no, emp_name, dep_no, jikup, hire_date, jumin_num, phone_num, mgr_emp_no
	from
		employee
-

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<147> employee_vw1 에 데이터 '이승엽', 40, '과장', '1990-09-01', '7811231452719', '01090056376', 1 를 입력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	뷰에 insert 를 하면 뷰의 근원이되는 원본 테이블에 insert 된다.
	무조건 insert 되는 것은 아니고 원본 테이블에 insert 되는 상황이어야한다.
	-----------------------------------------------------------------
	insert into employee_vw1 (
		emp_no, emp_name, dep_no, jikup, hire_date, jumin_num, phone_num, mgr_emp_no
	)values(
		(select nvl(max(emp_no), 0)+1 from employee_vw1) -- 맨처음 들어갈때 null 이 뜰수 있기 때문에 nvl 써준다.
			, '이승엽', 40, '과장', to_date('1990-09-01', 'YYYY-MM-DD'), '7811231452719', '01090056376', 1
	);
	-----------------------------------------------------------------
	-----------------------------------------------------------------
	비록 뷰 employee_vw1 에 insert 를 했지만, 실제로는 employee 테이블에 입력된 것이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<148> 뷰 employee_vw1 에서 주민번호 '7811231452719', 직원명 '이승엽'의 직급을 부장으로 수정하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	뷰에 update 를 하면 뷰의 근원이되는 원본 테이블에 update 된다.
	무조건 update 되는 것은 아니고 원본 테이블에 update 되는 상황이어야한다.
	-----------------------------------------------------------------
	update 테이블명 set 컬럼명 = 수정데이터, ~ where 조건식
	update employee_vw1 set jikup='부장' where emp_name='이승엽' and jumin_num='7811231452719'
	select * from employee;
	select * from employee_vw1;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<149> 뷰 employee_vw1 에서 주민번호 '7811231452719' 인 직원을 제거하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------------------
	뷰에 delete 를 하면 뷰의 근원이되는 원본 테이블에 delete 된다.
	무조건 delete 되는 것은 아니고 원본 테이블에 delete 되는 상황이어야한다.
	-----------------------------------------------------------------
	delete from employee_vw1 where jumin_num='7811231452719';


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<150> 뷰 employee_vw1 를 제거하면
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	drop view employee_vw1;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<151> 다음 뷰에 대한 질문에 대답하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	create view employee_vw4 as
	select emp_no, emp_name, dep_no from employee;
	-------------------------------------------------------------------
	<문>위의 뷰를 만든 후 insert into employee_vw4 values( 21, '사오순', 40); 실행하면 성공하나 실패하나?
	-------------------------------------------------------------------
	▶실패한다. 뷰 employee_vw4 에 입력되는 데이터는 employee 테이블에 입력되는 것과 같다.
		employee 테이블에서 not null, unique 등의 제약조건에 위반되기 때문에 못들어 간다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<152> 다음 뷰에 대한 질문에 대답하면? (기)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------
	insert into dept values(60, '전략부', '부산');
	--------------------------------------------
	create view dept_vw1 as
		select dep_no, dep_name, loc from dept
		where dep_no=60 with check option;
	--------------------------------------------
	<문>update dept_vw1 set dep_no=70 where dep_no=60; 을 실행하면?
	--------------------------------------------
		▶실패. WITH CHECK OPTION 이 있으면 where 조건에 위배되는 입력, 수정은 불가능하다.
		▶즉, dept_vw1 란 이름의 view 의 목적은 60번 부서를 검색하는게 목적이므로 이 목적 위배하는 행위는 하지마라
			위배하면 60번 부서를 검색하지 못하게 되니까 위배하지 마라의 의미가 있다.
	--------------------------------------------
	<문>insert into dept_vw1 values(70, '미래부', '대구'); 을 실행하면?
	--------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<153> 다음 뷰에 대한 질문에 대답하면? (기. 입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

----------------------------------------------------
create view employee_vw6 as
select emp_no, emp_name, dep_no, jikup, salary from employee where salary>=3000
with check option;
----------------------------------------------------
	----------------------------------------------------
	<문> update employee_vw6 set salary=salary*0.95 where salary>=3000을 실행하면??
	----------------------------------------------------
	▶실패. WITH CHECK OPTION 이 있으면 where 조건에 위배되는 입력, 수정이 발생할 경우에만 불가능하다.
	▶현재 5% 인하해서 3000 밑으로 내려가는 직원이 있으므로 이번 update는 실패한다.
	▶만약 5% 인하해서 3000 밑으로 내려가는 직원이 없다면 이 update는 성공할 것이다.
	----------------------------------------------------
	<문> update employee_vw6 set salary=salary*1.95 where salary>=3000을 실행하면??
	----------------------------------------------------
	▶성공. 업데이트로 3000 미만으로 내려가지 않아 조건에 위배되지 않으므로 성공한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<154> 다음 뷰에 대한 질문에 대답하면? (기. 입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------------------
create view employee_vw7 as
select emp_no, emp_name, dep_no, jikup, salary from employee where salary>=3000 with check option;
----------------------------------------------------
	----------------------------------------------------
	<문> update employee_vw7 set salary=salary*0.95 where salary>=3100을 실행하면??
	----------------------------------------------------
	▶성공. WITH CHECK OPTION 이 있으면 where 조건에 위배되는 입력, 수정이 발생할 경우에만 불가능하다.
	▶현재 5% 인하해서 3100 밑으로 내려가는 직원이 없으므로 이번 update 는 성공한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<155> 뷰를 만드는 SQL 문법?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--------------------------------------------------------------------------------------------------
CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW 뷰이름 AS select문장 [WITH READ ONLY] [WITH CHECK OPTION];
--------------------------------------------------------------------------------------------------
	▶OR REPLACE
		▷동일한 뷰가 있으면 덮어쓴다. 즉 기존의 뷰가 갱신된다. 미사용 시 뷰 생성 불가능.
	▶FORCE
		▷존재하지 않는 테이블로부터 뷰를 만들 경우라도 뷰를 만든다.
		▷FORCE 에 의해 생성된 뷰를 select 로 검색하면 에러가 발생한다. 즉 이름만 존재하고 검색이 불가능한 뷰가 된다.
		▷뷰 생성 시 거론한 존재하지 않는 테이블을 나중에 만들고 나면 뷰도 select 로 검색이 가능하다.
	▶NOFORCE
		▷존재하지 않는 테이블에서 뷰를 만들 경우 뷰를 만들지 못한다.
		▷FORCE, NOFORCE 모두 생략 시 NOFORCE 설정과 같다.
	▶WITH READ ONLY
		▷뷰에 대해 입력, 수정, 삭제 작업이 불가능하다.
		▷생략 시 특정 조건에 하나의 테이블에서 만들어진 뷰에 대해서는 입력, 수정, 삭제 작업을 할 수 있고
			실존 테이블에 입력, 수정, 삭제가 된다.
	▶WITH CHECK OPTION
		▷뷰의 WHERE 구문 조건에 위배되는 방향으로 INSERT, UPDATE 작업은 불가능하다.
		▷<예>뷰에 where salary>=6000 이 있을 경우 salary>=6000 조건에 위배되는 방향으로 입력, 수정이 불가능하다.
					예를들어 salary>=6000 조건에 해당하는 행의 salary 를 6000 미만으로 입력, 수정하는 행위는 불가능하다
	▶생성한 뷰의 정보 검색 방법
		▷select view_name, text from user_views;
	▶select 문에서 실존 테이블에 존재하지 않는 컬럼은 반드시 별칭을 써야한다.

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<156> employee 테이블에 '장보고', 40, '대리', 3500, '2012-05-28', '8311091109310', 3 데이터를 입력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	----------------------------------------------------------------------------------
	시퀀스를 사용하여 PK 값을 입력 예
	----------------------------------------------------------------------------------
	insert into employee(
	    emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no
	)
	values(
	    emp_sq.nextval, '장보고', 40, '대리', 3500, to_date('2012-05-28','YYYY-MM-DD'), '8311091109310', '01092499215', 3
	);
	----------------------------------------------------------------------------------
	서브쿼리를 사용하여 PK 값을 입력 예
	----------------------------------------------------------------------------------
	insert into employee(
	    emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no
	)
	values(
	   (select nvl(max(emp_no), 0)+1 from employee),
		 '장보고', 40, '대리', 3500, to_date('2012-05-28','YYYY-MM-DD'), '8311091109310', '01092499215', 3
	);
	----------------------------------------------------------------------------------
	select * from employee; ==> insert 확인.
	commit;                 ==> insert 작업 인정. insert 작업 취소 시 rollback; 실행.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<157> employee 테이블에 직원번호가 18번이고 주민번호 8203121977315인 강감찬 직원의 직급을 주임으로 수정하려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------------------------------------
	주민번호로 찾아서 수정한 경우 답 (좋은 답이 아니다. 왜? 주민번호는 DBA가 준 값이 아니므로 신뢰도가 떨어진다.)
	----------------------------------------------------------------------------------
	update
		employee
	set
		jikup = '주임'
	where
		emp_name = '강감찬'
		and
		jumin_num = '8203121977315';

	----------------------------------------------------------------------------------
	PK로 찾아서 수정한 경우 답 (좋은 답이다. 왜? PK는 DBA가 준 값이니까. 신뢰도가 높다.)
	----------------------------------------------------------------------------------
	update
		employee
	set
		jikup = '주임'
	where
		emp_no = '18';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<158> 여성 직원의 월급을 500만원 인상하는 update 문은?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		substr(jumin_num,7,1) = '2' or substr(jumin_num,7,1) = '4'
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		substr(jumin_num,7,1) in ('2', '4') -- in으로 표현
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		substr(jumin_num,7,1) = any('2', '4') -- any로 표현
	----------------------------------------------------------------------------------
	update
		employee
	set
		salary = salary + 500
	where
		jumin_num like '______2%' or jumin_num like '______4%' -- like 로 표현.
	----------------------------------------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<159> employee 테이블에서 평균 연봉 이상의 직원 연봉을 2% 삭감하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

update
 employee
set
	salary = salary * 0.98
where
	salary >= (select avg(salary) from employee);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<160> employee 테이블에서 평균 연봉 보다 작은 연봉자의 연봉을 50만원 인상하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

update
 employee
set
	salary = salary + 50
where
	salary < (select avg(salary) from employee);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<161> 담당 고객이 있는 직원의 급여를 5% 인상하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
update
 employee
set
	salary = salary * 1.05
where
	-- emp_no in (고객을 담당하는 직원번호가 , 로 나열되면됨.) -- n행 1열 서브쿼리 들어가야함.
	emp_no in (select distinct emp_no from customer where emp_no is not null)
------------------------------------------------------------------------------------------------
update
 employee
set
	salary = salary * 1.05
where
	emp_no = any (select distinct emp_no from customer where emp_no is not null)
------------------------------------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<162> 연봉서열에서  2행~5행 까지 4명의 연봉을 10% 인하하면?
	정렬기준 = 연봉높은순서 => 직급높은순서 => 입사일 빠른순서 => 나이높은순서
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

update
	employee
set
	salary = salary * 0.9
where
	emp_no in(
		select emp_no from ( select rownum RNUM, zxcvb.* from (

			select emp_no from employee
			order by
			salary desc
			, decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4) asc
			, hire_date asc
			, decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6) asc

		) zxcvb where rownum<=5 ) where RNUM>=2;
	)
-----------------------------------------------------------------------------------------------------
update
	employee
set
	salary = salary * 0.9
where
	emp_no in(
		select emp_no from ( select rownum RNUM, zxcvb.* from (

			select emp_no from employee
			order by
			salary desc
			, decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4) asc
			, hire_date asc
			, decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6) asc

		) zxcvb ) where RNUM>=2 and RNUM<=5;
	)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<163> employee 과 똑같은 구조와 똑같은 데이터를 가진 쌍둥이 테이블 employee2 만들면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	create table employee2 (
		컬럼명 자료형 제약조건...
		,컬럼명 자료형 제약조건...
		,컬럼명 자료형 제약조건...
	)
------------------------------------------------------------
	create table employee2 as select * from employee;
------------------------------------------------------------
위 SQL 구문은 select 결과물을 실존 테이블로 만드는 SQL 구문이다.
위 SQL 구문으로 테이블 복사하면 데이터, 컬럼명, 자료형, 자료형크기, not null 제약 조건만 그대로 복사된다.
<주의>
not null 제약조건 이외의 제약조건은 따라오지 않는다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<164> employee 과 똑같은 구조를 가진 쌍둥이 테이블 employee3 만들되 데이터는 복사해 오지 않으려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
------------------------------------------------------------
	create table employee3 as select * from employee where 1=2;
------------------------------------------------------------
where 조건절에 계속 false 가 되는 조건을 걸면 컬럼명, 자료형, 자료형크기, not null 제약 조건만 그대로 복사되고
데이터는 복사되지 않는다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<165> 게시판에 입력되는 데이터를 저장하려면 테이블 구조는 어떻게 설계해야 될까? <입.>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

`group_no`, `print_no`, `print_level` 이 세가지를 잘 파악해야 한다.

create table board (
b_no        number(9)                        --> 게시판 글 고유번호

,subject     varchar2(50)     not null            --> 글 제목
,writer      varchar2(30)     not null            --> 글쓴이 이름
,content     varchar2(2000)   not null            --> 글 내용
,pwd         varchar2(12)     not null            --> 암호
,email       varchar2(30)                         --> 이메일

,reg_date    date            default sysdate     --> 등록일
,readcount   number(5)       default 0           --> 조회수

,group_no    number(9)       not null            --> 게시판 글의 소속 그룹번호. 정렬 시 사용.
,print_no    number(9)       not null            --> 같은 그룹번호 내에서 화면 출력 순서 번호. 정렬 시 사용.

,print_level number(9)       not null            --> 같은 그룹번호 내에서 댓글 들여쓰기 레벨 단계 번호. 부모 자식 관계를 알 수 있다.

,primary key(b_no)
)

select * from board;

-------------------------------------------------------------
	----------------------------------
	<새끼문제> 정렬에 관련된 컬럼은?
	----------------------------------
		group_no, print_no
		----------------------------------
		정렬시
		먼저 그룹번호를 내림차순으로 정렬하고, 같은 그룹번호 내에서 화면 출력 순서를 오름차순으로 정렬할 것이다.
	----------------------------------
	<새끼문제> 부모자식 관계를 표현하는데 사용되는 데이터가 있는 컬럼은?
	----------------------------------
		print_level
		----------------------------------
		자식은 부모보다 1단계 오른쪽으로 밀려들어가게 만든다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<166> 게시판이 오픈 된 후 처음으로 누군가 아래처럼 글을 올렸다. insert 구문을 쓰면?
	글제목   => 11월 모두 취업합시다.
	글내용   => 어쩌구 저쩌구
	글쓴이   => 희원
	이메일   => hwon@naver.com
	비밀번호 => 1234
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
/*
create sequence boar_sq
  start with 0
  increment by 1
  minvalue 0
  maxvalue 999999999;
*/

insert into board(
	b_no
	, subject
	, writer
	, content
	, pwd
	, email
--	, reg_date  -- default 값이 있으므로 등록하지 않아도 된다.
--	, readcount -- default 값이 있으므로 등록하지 않아도 된다.
	, group_no
	, print_no
	, print_level
)

values(
--board_sq.nextval
	(select nvl(max(b_no),0)+1 from board) -- PK넘버.
	, '11월 모두 취업합시다'
	, '희원'
	, '어쩌구 저쩌구'
	, '1234'
	, 'hwon@naver.com'
	--, sysdate -- default 값이 있으므로 등록하지 않아도 된다.
	--, 0       -- default 값이 있으므로 등록하지 않아도 된다.
	, (select nvl(max(b_no),0)+1 from board)
	, 0
	, 0
);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<167> 누군가 게시판 번호 1번 에 아래처럼 댓글을 올렸다. 이때 댓글 올리는 과정 중에 발생되는 SQL 모두 써라.
	글제목   => 맞습니다. 열공합시다.
	글내용   => 어쩌구 저쩌구
	글쓴이   => 영민
	이메일   => min@naver.com
	비밀번호 => 2345
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------
	-- 부모글의 조회수를 1 업데이트하기
	update board set readcount = readcount + 1 where b_no=1;
	-----------------------------------------------------
	-- 밑으로 내리는 글의 출력 순서번호를 1 업데이트하기
	update board set print_no = print_no + 1
	where group_no = (select group_no from board where b_no = 1) -- b_no가 1번인 글의 그룹번호
		and
		print_no > (select print_no from board where b_no = 1) -- b_no 가 1번인 글의 출력순서번호
	-----------------------------------------------------
	-- 댓글 입력하기
	insert into board (
	  b_no
		, subject
		, writer
		, content
		, pwd
		, email
	  , group_no
	  , print_no
	  , print_level
	)
	values (
	  (select nvl(max(b_no),0)+1 from board)
	  , '맞습니다. 열공합시다.'
		, '영민'
		, '어쩌구 저쩌구'
		, '2345'
		, 'min@naver.com'
	  , (select group_no from board where b_no=1) -- b_no가 1번인글의 그룹번호
	  , (select print_no + 1 from board where b_no=1) -- b_no가 1번인글의 출력순서번호에 1더한거
	  , (select print_level + 1 from board where b_no=1) -- b_no가 1번인글의 들여쓰기번호에 1더한거
	)

-
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<168> 게시판의 모든 글을 출력하면?
		출력되는 데이터는 단순역순번호, 제목, 글쓴이, 작성일(년-월-일), 조회수 이다.
		-----------------------------------------
		정렬 기준
		-----------------------------------------
			그룹번호 내림차순
			출력순서번호 오름차순
		-----------------------------------------
		print_level 컬럼안의 데이터를 가지고 들여쓰기를 표현하십쇼
		-----------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-- 정답.
select
  x.cnt - rownum+1 "번호", b.*
from
(
select
  lpad( ' ', print_level*5, ' ' )||decode(print_no, 0, '', 'ㄴ')||subject "글제목"
  ,writer                                  "글쓴이명"
  ,to_char(reg_date, 'YYYY-MM-DD')         "등록일"
  ,readcount                               "조회수"
from
  board
order by
  group_no desc
  ,print_no asc
) b, (select count(*) CNT from board) x

--------------------------------------------------
select
  x.cnt - rownum+1 "번호", b.*
from
(
select
  lpad( ' ', print_level*10, ' ' )||decode(print_no, 0, '', 'ㄴ')||subject "글제목"
  ,writer                                  "글쓴이명"
  ,to_char(reg_date, 'YYYY-MM-DD')         "등록일"
  ,readcount                               "조회수"
from
  board
order by
  group_no desc
  ,print_no asc
) b, (select count(*) CNT from board) x


	-------------
	lpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 오른쪽 정렬 후 왼쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.

select lpad( 'abc', 7, ' ' ) from dual;



-- 내가 해본것.
select
  rownum RNUM
  ,b.*
from
(
select
,lpad( ' ', print_level*5, ' ' )||decode(print_no, 0, '', 'ㄴ')||subject '글제목'
,writer                                  "글쓴이명"
,to_char(reg_date, 'YYYY-MM-DD')         "등록일"
,readcount                               "조회수"
from
  board
order by
  group_no asc
  ,print_no desc;
) b
order by RNUM desc;


-- 강사님 정순, 역순번호. 설명
--정순번호
select
	rownum
	,e.*
from
	employee e


--역순번호 --서브쿼리 : 매번 서브쿼리가 실행되어 부하가 걸린다.
select
	(select count(*) from employee) - rownum + 1 no_desc --역순번호(서브쿼리)
	,rownum                                       no_asc
	,e.*
from
	employee e
------------------------------------------------------------------------------
--역순번호 -- 인라인뷰 : 부하를 덜 주게 작성.

select
	 x.cnt - rownum + 1 no_desc --역순번호(서브쿼리)
	,rownum                                       no_asc
	,e.*
from
	employee e, (select count(*) CNT from employee) x

















■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<???> 부서별, 직급별로 [부서번호], [부서명], [직급], [평균연봉] 을 출력하는 뷰 employee_vw3를 생성하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
create view employee_vw3 as
	select d.dep_no "dep_no", d.dep_name "dep_name", e.jikup "jikup", avg(e.salary) "avg_salary"
	from employee e,  dept d
	where e.dep_no=d.dep_no
	group by d.dep_no , d.dep_name, e.jikup
	order by  "dep_no", "avg_salary" desc

	--><주의>avg(salary) "avg_salary"에서 별칭 "avg_salary"을 생략하면 안된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<> 직급별, 평균 연봉 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	jikup
	,avg(salary)
from
employee
group by
	jikup;

			select * from employee where emp_name like '%김%'
			select * from employee where instr(emp_name, '김')>0;
			------------------------------------------------------------
			select * from employee where instr(emp_name, '김')=1;
			select * from employee where emp_name like '김%'
=======================================================
