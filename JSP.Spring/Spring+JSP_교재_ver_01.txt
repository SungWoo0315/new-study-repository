■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문1> 웹브라우저(=WEB Browser) 란? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    -----------------------------------------------------------------
    인터넷 망에서 URL 주소에 존재하는 [웹서버]로 [요청 메시지]를 전송하고,
    [응답 메시지]를 받아 그안에 존재하는 [HTML 소스]를 실행하여
    결과를 화면에 출력하는 클라이언트 쪽 SW를 말한다.  
    -----------------------------------------------------------------
    <예> Explore9, Explorer10, Explorer11, Chrome, Safari, Opera, Firefox, Edge    
    -----------------------------------------------------------------
 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문2> 웹서버(=WEB Server) 란? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    -----------------------------------------------------------------
    [웹브라우저] 로 접속하는 [다수]의 [클라이언트]의 [요청 메시지] 을 받고,
    다수의 클라이언트에게 [동시에] [응답 메시지] 로 응답하는 SW 를 말한다.  
    -----------------------------------------------------------------
    웹서버 종류
    -----------------------------------------------------------------
        Weblogic        => 웹프로그래밍 자원으로 HTML, JSP, Java 를 사용한다. 실무용.    ★★
        Websphere       => 웹프로그래밍 자원으로 HTML, JSP, Java 를 사용한다. 실무용.  
        JBoss           => 웹프로그래밍 자원으로 HTML, JSP, Java 를 사용한다. 실무용.   
        Tomcat          => 웹프로그래밍 자원으로 HTML, JSP, Java 를 사용한다. 연습용.    ★
        -----------------------------------------------------------------
        IIS             => 웹프로그래밍 자원으로 HTML, ASP, C#, 닷넷 을 사용한다. MS쪽.  
        -----------------------------------------------------------------
        Apache          => 웹프로그래밍 자원으로 HTML, PHP 를 사용한다.  
        -----------------------------------------------------------------
        NodeJS          => 웹프로그래밍 자원으로 자바스크립트(*.js) 를 사용한다.          ★
                        => <참고> React 가 NodeJS 위에서 작동된다.  
        -----------------------------------------------------------------
        기타 JEUS(Tmax), iPlanet, Oracle 9iAS 등 의 웹서버도 있다.    
        -----------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문3> [웹브라우저]와 [웹서버]의 통신 과정을 설명하면? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

*******************************************************************
<1> 일반 유저가 [웹브라우저]에서 원하는 [웹서버]의 자원을 호출하기 위해 아래와 같은 [URL 주소]로 입력하고 엔터를 친다.
    이때, [요청메시지]를 가지고 [웹서버]에 접속을 시도한다.
*******************************************************************
    -----------------------------------------------------
    http://서버의도메인주소:웹서버포트번호/웹서버의호출자원명
    -----------------------------------------------------
    -----------------------------------------------------
    <참고> [요청 메시지]의 내용물? ★★★★★
    -----------------------------------------------------
        ----------------------------  
        URL 주소
        ----------------------------  
        [파라미터명] 과 [파라미터값]    => 클라이언트 쪽 입력양식 태그의 name값과 value값 을 말한다.  
                                      => URL 주소에 물음표 이후 문자열 중 xxx=yyy 가 있으면
                                         xxx 가 [파라미터명]이고 yyy 가 [파라미터값]이다.
        ----------------------------  
        [쿠키명]과 [쿠키값] 
        ----------------------------  
        [헤더명]과 [헤더값]            => 클라이언트 웹브라우저의 각종 정보,
        ----------------------------  
        기타 등등
        ----------------------------  
    -----------------------------------------------------
    <참고> : 웹서버포트번호 가 생략되면 :80 가 디폴트값이다.
    -----------------------------------------------------
    <참고> 웹서버의 호출자원명 없이 http://서버의도메인주소:웹서버포트번호 로 접속을 시도하면
           [웹서버]는 디폴트 대응 자원명을 호출한다.  
    -----------------------------------------------------
    <참고> URL 주소 중 http://서버의도메인주소 까지는 유일한 값이다.  
           즉, 중복되지 않는 유일한 대외적인 주소이다.
           만약, 서버의 도메인주소가 www 로 시작한다면 전세계의 유일한 주소이다.  
           만약, 서버의 도메인주소가 www 로 시작 안하면 국내의 유일한 주소이다.  
    -----------------------------------------------------
    <참고> URL 주소 중 http://서버의도메인주소 이후의 주소는 웹서버 내부의 주소이다.  
    -----------------------------------------------------

*******************************************************************
<2> 인터넷 망을 타고 가다 [DNS 서버]에 들려 아래와 같이 [URL 주소]가 바뀐다.
*******************************************************************
    -----------------------------------------------------
    http://서버의도메인주소:웹서버포트번호/웹서버의호출자원명
    -----------------------------------------------------
    ↓
    -----------------------------------------------------
    http://서버의도메인주소에대응하는IP주소:웹서버포트번호/서버의호출자원명
    -----------------------------------------------------
    DNS 서버에는 서버의 도메인주소 에 대응하는 IP 주소가 등록되어 있다.  

*******************************************************************
<3> [DNS 서버]를 출발하여 인터넷 망을 타고 가다 [IP 주소]를 소유한 [서버 운영체제]에 접속한다.  
*******************************************************************
    <참고> [서버 운영체제]는 대부분 [Unix] 또는 [서버용윈도우] 또는 [Linux] 이다.
           Linux 는 대규모가 아닌 중소기업용이다.  

*******************************************************************
<4> [서버 운영체제] 내부에 웹서버포트번호를 이용하는 [웹서버]에 접속한다.  
*******************************************************************

>>>> 5번 부터 개발자가 신경 써야 한다.  
*******************************************************************
<5> [웹서버]가 URL 주소에 있는 [서버의호출자원명]에 대응하는 [웹프로그래밍 자원]을 호출한다.  
    이때, [웹프로그래밍 자원]에게 [요청 메시지] 안의 파라미터명, 파라미터값, 쿠키명, 쿠키값 이 전달된다.  
*******************************************************************
    -----------------------------------------------------
    파라미터명, 파라미터값은 DB 연동 시 사용한다.  
    -----------------------------------------------------
    바로 파라미터명 이 오라클  테이블의 컬럼명이고, 
    파라미터값은 테이블에 입력 또는 삭제 또는 수정 또는 검색할 데이터다.  
    -----------------------------------------------------
    쿠키명, 쿠키값은 아주 가끔 DB 연동 시 사용한다.  
    -----------------------------------------------------
    [웹프로그래밍 자원]이 JSP 라면 xxx.jsp 가 호출된다.
    [웹프로그래밍 자원]이 자바의 객체라면 특정 메소드가 실행된다.  

*******************************************************************
<6> [웹프로그래밍 자원]이 필요에 따라 파라미터명, 파라미터값을 가지고 DB 연동(입력,수정,삭제,검색)을 하고
    그 결과물을 HTML 소스에 반영하여 HTML 소스를 생성한다.  
*******************************************************************
    -----------------------------------------------------
    <참고> DB 연동이 필요없는 경우 HTML 소스에 DB 연동 결과물이 반영되지 않을수도 있다.  
    -----------------------------------------------------
    <참고> 스프링프레임워크에서는 필요에 따라 HTML 소스가 아닌 JSON 을 생성하기도한다.  
    -----------------------------------------------------
    <참고> 웹프로그래밍 자원을 어떤 구조로 만드냐에 따라 아래와 같은 [웹 개발 패턴]으로 나뉜다.  
    -----------------------------------------------------
        -----------------------------------------------------
        Model1 패턴
        -----------------------------------------------------
            ⅰ 클라이언트의 웹브라우저에서 http://~/xxx.jsp 형태의 [URL 주소]로 웹서버에 접속한다.
            ⅱ [웹서버]에서 [URL 주소]에 대응하는 xxx.jsp 파일이 실행된다.
            ⅲ xxx.jsp 파일이 실행된 후 HTML 소스가 생성된다.
            ⅳ [웹서버]가 [응답메시지]에 HTML 소스 등을 담아 클라이언트의 웹브라우저에게 [응답메시지]를 전송한다.
            ⅴ 클라이언트의 웹브라우저에서 HTML 소스가 실행되어 웹화면에 결과를 본다.
            -------------------------------------------------
            <장점> 프로젝트 규모가 작고, 유지보수가 많지 않을 경우 작업 속도가 매우 빠르다.    
            <단점> 프로젝트 규모가 크고, 유지보수가 많을 경우 사용하기 힘들다.
            -------------------------------------------------

        -----------------------------------------------------
        Model2 패턴
        -----------------------------------------------------
            ⅰ 클라이언트의 웹브라우저에서 http://~/xxx.do 형태의 [URL 주소]로 웹서버에 접속한다.
               xxx.do 는 xxx, xxx.html, xxx.action 등으로 표현되는 가짜 자원명이 있다. 

            ⅱ [웹서버]의 [Servlet 객체]의 특정 메소드가 호출된다. 모든 형태의 URL 주소 접속 시 이 Servlet 객체가 맞이 한다.  
            ⅲ Servlet 객체의 특정 메소드에서 [URL 주소]에 대응하는 자바 객체(=JavaBean)의 메소드를 호출한다.
               이 자바 객체(=JavaBean) 메소드 안에서 DB 연동을 하고 결과물을 Servlet 객체에 리턴한다.  


            ⅳ Servlet 객체의 특정 메소드에서 [URL 주소]에 대응하는 xxx.jsp 파일을 호출한다.  
            ⅴ xxx.jsp 파일이 실행되면서 DB 연동 결과물을 HTML 소스에 반영하여 HTML 소스를 생성한다.  
            ⅵ [웹서버]가 [응답메시지]에 HTML 소스 등을 담아 클라이언트의 웹브라우저에게 [응답메시지]를 전송한다.
            ⅶ 클라이언트의 웹브라우저에서 HTML 소스가 실행되어 웹화면에 결과를 본다.  
            -------------------------------------------------
            <단점>
            -------------------------------------------------
                Model1 패턴 보다 유지보수성이 좋아졌지만,
                시대의 흐름에 따라 프로젝트 규모가 커지기 시작하자 또 유지보수성이 현저히 낮아지게 된다.
                왜? Model1 보다 체계적이기는 하나 Model1 과 동일한 점은 개발자 코딩 개성이 들어간다.  
                즉, 코딩 습관이나 사용하는 객체가 개발자 개성에 따라 다 다르다. 
            -------------------------------------------------
            <참고> [Servlet 객체]란 [HttpServlet 클래스]를 상속받은 객체를 말한다.  
            -------------------------------------------------
                ---------------------------------------------
                <예>
                ---------------------------------------------
                public Xxx extends HttpServlet{
                        ~~~
                }
                ---------------------------------------------
                > Xxx 클래스가 객체화 된다면, 통상적으로 [Servlet 객체]라고 지칭한다.  
                > Spring MVC 패턴에서는 [Servlet 객체]를 개발자가 만들지 않고, Spring 쪽에서 제공한다.  
                ---------------------------------------------

        -----------------------------------------------------
        Spring MVC 패턴
        -----------------------------------------------------
            Spring framework 에서 지원하는 웹 개발 패턴이다.  
            작동 구조는 Model2 방식과 거의 동일하나 더 많은 자바 객체가 동원된다.  
            Model2 방식의 자바 객체(=JavaBean)와 비슷한 자바 객체가 Spring MVC 방식에서는 더 세분화되어 여러 층으로 나뉜다.  
            DB 연동의 관리를 쉽게하기 위함이다. 
            현재 대기업이나 공기업 프로젝트에서는 주로 사용하는 개발 패턴이다.  
            
            <참고> 추후 문제에서 따로 자세히 서술한다.  
            -------------------------------------------------
            <장점>
            -------------------------------------------------
                프로젝트 규모가 클수록 유지보수성이 좋다.  
                Spring MVC 에서 정한 코딩 패턴과 정해진 객체를 사용하기 때문이다.  
                자바 객체 안에서 어노테이션(=anotation)을 적극적으로 사용하여 자바의 날 코딩이 줄어든다.  
                속성변수의 자료형으로 [인터페이스]를 적극적으로 사용하여 객체 간의 [결합도]를 
                    약하게 하여 [연쇄 수정의 범위]를 줄인다. (=유지보수성 증가)
                DB 연동 시 작성하는 SQL 구문을 자바 객체 안에서 하지 않고 XML 로 빼서 작업하기도 한다. 
                    이때 [mybatis] 라는 프레임워크를 사용한다. 
                ---------------------------
                <참고> 어노테이션(anotation)
                ---------------------------
                    클래스명 앞, 메소드 앞, 속성변수 앞, 매개변수 앞에 붙어
                    특정 기능을 부여하는 자바의 표기법.  

            -------------------------------------------------
            <단점>
            -------------------------------------------------
                환경 설정이 복잡하다.
                작동 원리가 복잡하기에 사전 학습이 힘들다. 
                규모가 작거나 유지보수가 많이 필요하지 않은 경우 프로젝트에서 어울리지 않는다.
                규모가 크면 DB의 테이블 개수가 많아진다.
                즉, 프로젝트의 규모는 DB의 테이블 개수와 비슷하다.    

*******************************************************************
<7> DB 연동 결과물이 만영된 HTML 소스를 [웹서버]로 전해준다
*******************************************************************

*******************************************************************
<8> [웹서버]는 [응답 메시지]를 만든다.  
*******************************************************************
    ----------------------------
    [응답 메시지]의 내용물
    ----------------------------
        DB연동 결과물을 반영한 HTML 소스   
        쿠키명과 쿠키값   
        헤더명과 헤더값   => 웹서버에 관련된 정보.  [요청 메시지]와 다른것을 기억.  
        접속자가 요청한 자원의 존재 여부 및 재 접속 여부.  

*******************************************************************
<9> [웹서버]는 [웹브라우저]에게 [응답 메시지]를 전송한다.  
*******************************************************************

*******************************************************************
<10> [응답 메시지]를 받은 [웹브라우저]는 [응답 메시지]에 내장된
     요청 자원의 존재 여부를 확인하고 난 후, 있다면
     HTML 소스를 실행하여 [웹브라우저] 화면에 출력한다.
*******************************************************************
    <참고>
    요청 자원의 존재 여부 확인 시 없다면
    에러 메시지가 존재하는 자체 준비 HTML 문서를 실행하여 화면에 출력한다.  


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문4> 위 [웹브라우저]와 [웹서버]의 통신 과정에서 개발자가 기억할 것과 작업해야할 것을 정리하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    신경 써야 할 과정번호
        <5>  <6>
    ------------------------------------
    작업해야할 것.
    ------------------------------------
        --------------------------------
        접속 [URL 주소]를 기억.
        --------------------------------
        [URL 주소]에 대응하는 자바 객체(=JavaBean)의 전신인 클래스 제작.
        --------------------------------
        DB 연동 시 필요한 SQL 구문 제작.  
        --------------------------------
        html 소스를 생성하는 xxx.jsp 제작.  
        --------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문5> [웹브라우저]가 [웹서버]로 보낸 [요청메시지]를 관리하는 것이 무엇입니까?  (입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    --------------------------------------------------------------
    [HttpServletRequest] 객체이다. 웹서버가 지원해주는 객체이다.  
    --------------------------------------------------------------
    <참고> JSP 페이지에서는 [HttpServletRequest] 객체를 request 객체라고 부르기도 한다.  
           JSP 페이지에서는 request 변수안에 [HttpServletRequest] 객체의 메모리 위치 주소값이 저장되어 제공된다.  
           이 변수 이름을 객체이름으로 부르기도 합니다.  
    --------------------------------------------------------------
    [HttpServletRequest] 객체 메소드   ★★★★★
    --------------------------------------------------------------
        -------------------------------------
        String getParameter( "파라미터명" )
        -------------------------------------
            [요청 메시지] 안에 담긴 [파라미터명]에 대응하는 [파라미터값]을 String 형으로 리턴한다.  
            [파라미터명]이 없을 경우 에러발생하지 않고 [null 값]이 리턴됨.  
            동일한 [파라미터명]이 2개 이상일 경우 첫번째의 파라미터명의 파라미터값만 리턴한다. 
            //ex) 파라미터명이 2개 이상인 checkBox 입력양식.  
                ---------------------------------------------------------------------
                <예>
                ---------------------------------------------------------------------
                아이디 : <input type="text" name="uid">
                암  호 : <input type="password" name="pwd">
                ---------------------------------------------------------------------
                위의 html 소스의 웹화면 실행결과물에서 아이디는 "abc", 암호는 "123" 을 입력한 상태에서
                특정 웹서버에 접속하면
                이때 웹서버로 전달되는 요청메시지 안의 파라미터명과 파라미터값은 아래 처럼 저장되어 있다.  

                    "uid=abc&pwd=123"

                위에서 uid, pwd 은 파라미터명이 되고, abc 나 123 는 파라미터값이 된다. 
                즉, uid 이란 파라미터명에는 "abc" 가 대응되는 셈이다.  
                즉, pwd 이란 파라미터명에는 "123" 가 대응되는 셈이다.  

                웹서버에서 uid 이란 파라미터명에 대응하는 "abc" 을 꺼낼려면 아래처럼 코딩한다.  
                    -----------------------------------------------------------
                    String uid = request.getParameter( "uid" );
                    -----------------------------------------------------------
                        request 변수에는 [HttpServletRequest] 객체의 메위주가 저장되어 있다고 가정한다.   

                웹서버에서 pwd 란 파라미터명에 대응하는 "123" 을 꺼낼려면 아래처럼 코딩한다.
                    -----------------------------------------------------------
                    String pwd = request.getParameter( "pwd" );
                    -----------------------------------------------------------
                        request 변수에는 [HttpServletRequest] 객체의 메위주가 저장되어 있다고 가정한다.   

                ---------------------------------------------------------------------
                <예> radio button
                ---------------------------------------------------------------------
                <input type="radio" name="addr" value="서울">서울
                <input type="radio" name="addr" value="경기">경기
                <input type="radio" name="addr" value="인천">인천
                ---------------------------------------------------------------------
                위의 html 소스의 웹화면 실행결과물에서 "서울" 을 체크, 서울 을 체크한 상태에서 
                특정 웹서버에 접속하면
                이때 웹서버로 전달되는 요청메시지 안의 파라미터명과 파라미터값은 아래 처럼 저장되어 있다.  

                    "addr=서울"

                위에서 addr 은 파라미터명이 되고, "서울" 는 파라미터값이 된다. 
                즉, addr 이란 파라미터명에는 "서울" 가 대응되는 셈이다.  
                웹서버에서 addr 이란 파라미터명에 대응하는 파라미터값 "서울" 을 꺼낼려면
                아래처럼 코딩한다.  
                    -----------------------------------------------------------
                    String addr = request.getParameter( "addr" );
                    -----------------------------------------------------------
                        request 변수에는 [HttpServletRequest] 객체의 메위주가 저장되어 있다고 가정한다.   



        -------------------------------------
        String[] getParameterValues( "파라미터명" )
        -------------------------------------
            ▶ [요청 메시지] 안의 파라미터명에 대응하는 파라미터값을 String[] 형으로 리턴한다.  
            ▶ 주로 checkbox 에서 체크된 데이터를 받아올 때 사용하는 메소드이다.  
            checkbox 입력 양식이 2개 이상 있을 경우 name 값이 동일하고, value 값이 다르다.  
                ---------------------------------------------------------------------
                <예>
                ---------------------------------------------------------------------
                <input type="checkbox" name="skill" value="JSP">JSP
                <input type="checkbox" name="skill" value="ASP">ASP
                <input type="checkbox" name="skill" value="PHP">PHP
                ---------------------------------------------------------------------
                위의 html 소스의 웹화면 실행결과물에서 JSP 를 체크, ASP를 체크한 상태에서 
                특정 웹서버에 접속하면
                이때 웹서버로 전달되는 요청메시지 안의 파라미터명과 파라미터값은 아래 처럼 저장되어 있다.  

                    "skill=JSP&skill=ASP"

                위에서 skill 은 파라미터명이 되고, JSP 나 ASP 는 파라미터값이 된다. 
                즉, skill 이란 파라미터명에는 두 개의 파라미터값 JSP, ASP 가 대응되는 셈이다.  
                웹서버에서 skill 이란 파라미터명에 대응하는 두 개의 파라미터값 JSP, ASP 을 꺼낼려면
                아래처럼 코딩한다.  
                    -----------------------------------------------------------
                    String[] skills = request.getParameterValues( "skill" );
                    -----------------------------------------------------------
                        request 변수에는 [HttpServletRequest] 객체의 메위주가 저장되어 있다고 가정한다.   
                        결국, 배열변수 skills[0] 에 저장된 데이터는 "JSP" 이다.  
                        결국, 배열변수 skills[1] 에 저장된 데이터는 "ASP" 이다.  

                    > 변수이름 아래처럼 주는것이 구분하기 쉽다.  
                    String[] skillArr = request.getParameterValues( "skill" );
                    String[] skill_arr = request.getParameterValues( "skill" );
                    -----------------------------------------------------------

                        
        -------------------------------------
        void setAttribute( "키값문자열", 저장객체 )   ★★★★★ (입)
        -------------------------------------
            [키값문자열]에 [저장객체]를 연결하여 저장한다. HashMap 객체와 동일한 역할을 한다.  
            매개변수로 전달되는 저장객체는 주로 DB 연동 결과물이다.  

            DB 연동이 insert, update, delete 일 경우 [저장객체]는 [정수]이다.  
            DB 연동이 select 일 경우 DB 연동 결과물은 검색 결과에 따라 아래 처럼 다르다.  
                1행 1열 검색된 경우 => DB 연동 결과물은 [정수 또는 실수 또는 String] 이다.    
                1행 n열 검색된 경우 => DB 연동 결과물은 [HashMap 객체] 이다.    
                n행 1열 검색된 경우 => DB 연동 결과물은 [ArrayList, LinkedList, 배열 객체] 이다.    









■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문6> [웹서버]가 [웹브라우저]로 보내는 [응답메시지]를 관리하는 것이 무엇입니까?  (입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    --------------------------------------------------------------
    [HttpServletResponse] 객체이다. 웹서버가 지원해주는 객체이다.  
    --------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<문7> 임은지 씨가 네이버의 [웹서버]에 접속해서 로그인을 했다.   
      갑자기 백신 생각이 나서 백신 접종 사이트로 이동해서 접종예약을 했다.  
      다시 네이버로 접속했더니, 로그인 상태였다.  
      어떻게 네이버 웹서버에서 내가 재 접속한걸 알고 로그인 상태를 유지하고 있을까?  
      왜그럴까?     (입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    [웹브라우저]와 [웹서버]의 [연결 상태]를 관리하는 객체 때문이다. 
    그것이 바로, 
    --------------------------------------------------------------
    [HttpSession] 객체이다. 웹서버가 지원해주는 객체이다.   
    --------------------------------------------------------------
    <참고> [웹브라우저]와 [웹서버]의 [연결 상태]를 `세션(=session)`이라고 부른다.  

    --------------------------------------------------------------
    [웹브라우저]와 [웹서버]의 [연결 상태]를 관리하는 원리   ★★★★★ 입사시험문제 (입), (솔루션)
    --------------------------------------------------------------
        --------------------------------------------------------------
        <1> [클라이언트]가 종료된 [웹브라우저]를 실행 한 후 URL 을 입력하고 [웹서버]에 접속한다.  
        --------------------------------------------------------------
        <2> [웹서버]가 [HttpSession 객체]를 생성한다. [HttpSession 객체]는 [고유 아이디]를 가지고 있다.   
            개발자 코딩에 의해 [HttpSession 객체]에 원하는 데이터를 저장한다.  
        --------------------------------------------------------------
        <3> [웹서버]가 [응답 메시지]를 전송한다.
            이때 [응답메시지] 에는 [HttpSession 객체]의 [고유아이디]가 [쿠키]로 저장되어 있다.
        --------------------------------------------------------------
        <4> [웹브라우저]가 [응답메시지]를 받고, [응답메시지]안의 [고유 아이디]가 저장된 [쿠키]를 꺼내서 웹브라우저의 메모리 공간에 저장시킨다. 
            원래 쿠키값은 파일로 저장되는데, [고유 아이디]가 저장된 [쿠키]는 웹브라우저의 메모리 공간에 저장된다.  
            메모리 공간에 저장된다는 말은 웹브라우저가 종료되면 이 쿠키값도 삭제된다는 의미이다.  
        --------------------------------------------------------------
        <5> [클라이언트]의 [웹브라우저]가 URL을 입력하고 [요청 메시지]를 가지고 [웹서버]에 [재접속]한다.  
            이때, [요청 메시지]에는 쿠키로 저장된 [고유 아이디]가 들어 있다.
            만약, [요청 메시지]에는 쿠키로 저장된 [고유 아이디]가 없다면 <2>번 절차가 실행된다.     
            만약, [웹서버] 안에 [고유 아이디]를 가진 HttpSession 객체가 없다면 <2>번 절차가 실행된다. 
            만약, [웹서버] 안에 [고유 아이디]를 가진 HttpSession 객체가 수명이 다해서 제거된다면 <2>번 절차가 시행된다.  //로그인 유지 타임아웃.     
            HttpSession 객체의 수명은 코딩에 의해 설정된다.  
        --------------------------------------------------------------
        <6> [웹서버]는 [요청 메시지] 안의 [고유 아이디] 쿠키값을 꺼내어 
            이 [고유아이디]를 가진 HttpSession 객체를 찾아 대응시킨다.  
            [HttpSession 객체]에서 아까 접속 시 저장된 데이터를 꺼내서 어떤 작업을 한다.    
        --------------------------------------------------------------


















■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


●


▶️































